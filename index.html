<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Entry &#8211; 喵窝[0]号机</title>
<meta name="description" content="一个伪装成技术博客的吐槽网站。">

<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- mathjax -->
<script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$'], [ '\\(', '\\)']]}});
</script>


<meta http-equiv="content-type" content="text/html; charset=utf-8" />


<!-- Open Graph -->
<!-- <meta property="og:locale" content="en_US"> -->
<meta property="og:locale" content="zh_CN" />
<meta property="og:type" content="article">
<meta property="og:title" content="Entry">
<meta property="og:description" content="一个伪装成技术博客的吐槽网站。">
<meta property="og:url" content="http://MeowAlienOwO.github.io//index.html">
<meta property="og:site_name" content="喵窝[0]号机">





<link rel="canonical" href="http://MeowAlienOwO.github.io//">
<link href="http://MeowAlienOwO.github.io//feed.xml" type="application/atom+xml" rel="alternate" title="喵窝[0]号机 Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://MeowAlienOwO.github.io//assets/css/main.css">
<!-- Webfonts -->
<!-- <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css"> -->
<link href="//fonts.useso.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">
<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://MeowAlienOwO.github.io//assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://MeowAlienOwO.github.io//favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://MeowAlienOwO.github.io//favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://MeowAlienOwO.github.io//images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://MeowAlienOwO.github.io//images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://MeowAlienOwO.github.io//images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://MeowAlienOwO.github.io//images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://MeowAlienOwO.github.io//">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://MeowAlienOwO.github.io//images/avatar.png" alt="死鱼眼的喵星人 photo" class="author-photo">
					<h4>死鱼眼的喵星人</h4>
					<p>烈風？いいえ、知らない子ですね。（もぐもぐ</p>

				</li>
				<li><a href="http://MeowAlienOwO.github.io//about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:meowalienowo@outlook.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				
				
				
				
				<li>
					<a href="http://github.com/https://github.com/MeowAlienOwO"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://MeowAlienOwO.github.io//posts/">All Posts</a></li>
				<li><a href="http://MeowAlienOwO.github.io//tags/">All Tags</a></li>
				
				<li>
				  <a href="/categories/hello/">
				    hello (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/jekyll/">
				    jekyll (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/computer science/">
				    computer science (11)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/math/">
				    math (2)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/operating system/">
				    operating system (2)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/acg/">
				    acg (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/空之境界/">
				    空之境界 (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/c++/">
				    c++ (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/network/">
				    network (7)
				  </a>
				</li>
				
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  <div class="image-credit">Image source: <a href="http://www.pixiv.net/member_illust.php?mode=medium&illust_id=22958285">ZERO | STAR影法師 [pixiv]</a></div><!-- /.image-credit -->
  
    <div class="entry-image">
      <img src="http://MeowAlienOwO.github.io//images/22958285.jpg" alt="Entry">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>喵窝[0]号机</h1>
      <h2>一个伪装成技术博客的吐槽网站。</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io//computer%20science/network/application_layer/" title="Application Layer"><img src="http://MeowAlienOwO.github.io//images/50388846.jpg" alt="Application Layer"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-15T22:06:18+08:00"><a href="http://MeowAlienOwO.github.io//computer%20science/network/application_layer/">May 15, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io//about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io//computer%20science/network/application_layer/" rel="bookmark" title="Application Layer" itemprop="url">Application Layer</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>关于应用层，最后一篇……終わった……小天使求治愈www</p>

<h1 id="section">网络应用原则</h1>

<p>在处理应用时，我们需要考虑的是丢包，流量，是否时间敏感等等</p>

<h2 id="section-1">应用架构</h2>

<h3 id="section-2">客户端-服务端</h3>
<p>服务端：一直运行的主机，拥有固定IP地址，是数据中心。</p>

<p>客户端：可以同服务器通信，可以任意时刻链接，可能有动态IP地址，不需要互
相之间直接交流</p>

<h3 id="p2p">P2P</h3>

<p>不存在总是上线的服务器，各种终端系统自由交流。终端从别的终端得到服务，
同时也向他人提供服务。各个终端间歇性地连接在一起，需要复杂的管理手段。</p>

<h2 id="socket">套接字(socket)</h2>

<p>终端通过套接字发送/接收信息</p>

<p>地址处理：通过IP地址与接口号可以确定在主机上的程序。</p>

<h1 id="webhttp">Web与HTTP</h1>

<h2 id="httphypertext-transfer-protocal">超文本传输协议 HTTP:Hypertext transfer protocal</h2>

<p>网络的应用层协议，建立在C/S模型上。</p>

<ul>
  <li>客户端：发送浏览请求，通过http接受请求，然后展示网络对象。</li>
  <li>服务端：服务端根据请求返回网络对象</li>
</ul>

<p>使用TCP协议：</p>

<ul>
  <li>客户端初始化TCP连接，端口为80</li>
  <li>服务端接受客户端连接</li>
  <li>HTTP消息在浏览器与服务器之间传输</li>
  <li>结束TCP连接</li>
</ul>

<p>HTTP是”无状态”(stateless)的：服务端不需要保存过去的客户端请求。</p>

<h2 id="cookies">用户-服务器状态：cookies</h2>

<p>许多网站使用cookies。
Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行
session跟踪而储存在用户本地终端上的数据（通常经过加密）。定义于RFC2109
和2965都已废弃，最新取代的规范是RFC6265。服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookies，以便在最后付款时提取信息。</p>

<p>cookie头保存HTTP返回信息与下一个请求信息，cookie文件被用户主机所保存，
由用户浏览器管理。cookie与协议终点来共同维护状态。</p>

<h2 id="section-3">网络缓存(代理服务器)</h2>

<p>目的：在不打扰服务端的情况下满足客户端需求。</p>

<p>浏览器将所有的HTTP请求发送给缓存服务器。如果网络对象在缓存里，则直接返
回该对象；如果不在缓存里，则向源服务器发送请求，然后将对象保存在缓存里。</p>

<p>使用缓存可以减少请求-返回的时间，同时减少了信息交通量。缓存同时使得
“贫穷的”内容提供商可以有效地提供内容。</p>

<p>缓存同时保存一份最晚更新时间，当连接到服务器时，检查一下时间，如果不是
最新的，则更新缓存。</p>

<h1 id="section-4">电子邮件</h1>

<h2 id="smtp">SMTP</h2>
<p>三个主要组成：</p>

<ul>
  <li>用户代理(邮件阅读器):创建，编辑，读取邮件信息，发送与传入信息存储在
服务器上</li>
  <li>邮件服务器：信箱(mailbox)保存用户的传入信息，消息队列(message queue)
用于保存传出信息。</li>
  <li>简单邮件传送协议：SMTP(simple mail transfer protocal)：client-发送邮
件服务器，server-接收邮件服务器</li>
</ul>

<p>使用TCP传输，端口25。</p>

<p>从发送服务器到接收服务器直接传输</p>

<p>三个传输步骤：</p>

<ol>
  <li>握手</li>
  <li>传输信息</li>
  <li>关闭</li>
</ol>

<p>命令/回应交互</p>

<p>命令：ASCII文本
回应：状态码与短语</p>

<p>消息必须以7bitASCII文本传输。</p>

<p>SMTP以CRLF来判断信息终止。</p>

<p>信息格式：</p>

<p>头部+空行+信息主题</p>

<p>头部：To From Subject，不同与SMTP的FROM, RCPT, TO命令</p>

<p>主体：ASCII文本信息</p>

<h2 id="mail-access-protocal">邮件接入协议(mail access protocal)</h2>

<p>邮件接入协议：POP,IMAP,HTTP</p>

<ul>
  <li>POP3：下载-保存，将信息在客户端保存一份副本</li>
  <li>IMAP：所有的信息保存在服务器，允许用户以文件夹形式组织信息，通过会话
保存用户状态</li>
</ul>

<h1 id="domain-name-system-dns">域名系统(Domain Name System, DNS)</h1>

<p>分布式的数据库，通过许多命名服务器(name server)的层级关系实现。应用层
协议，主机与命名服务器交流来解析域名。</p>

<p>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。在RFC文档中RFC 2181对DNS有规范说明，RFC 2136对DNS的动态更新进行说明，RFC 2308对DNS查询的反向缓存进行说明。</p>

<h2 id="section-5">层级</h2>

<ol>
  <li>根服务器(root name server)</li>
  <li>com,org,edu…顶级服务器</li>
  <li>授权DNS服务器(authoritative DNS Server)</li>
  <li>本地DNS服务器(local DNS Server)</li>
</ol>

<h2 id="section-6">解析顺序</h2>

<p>主机-&gt;本地DNS-&gt;根服务器-&gt;顶级服务器-&gt;授权DNS服务器-&gt;目标主机</p>

<h2 id="section-7">缓存</h2>

<p>当一个命名服务器建立了映射，他会将该映射缓存。主要而言，本地服务器将缓
存这些映射以减轻根服务器与顶级服务器的压力。</p>

<p>但是，缓存可能过期，这会导致寻找不到目标主机。RFC2136标准定义了缓存更
新/通知机制。</p>

<h1 id="p2p-1">P2P应用</h1>

<h2 id="p2p-2">纯P2P架构</h2>

<ul>
  <li>没有一直运行的服务器</li>
  <li>任意数量的终端直接连接</li>
  <li>终端之间间歇性的链接，可能改变IP地址。</li>
</ul>

<p>例子：</p>

<ul>
  <li>文件分布(BitTorrent, BT协议)</li>
  <li>流媒体(迅雷看看？！)</li>
  <li>VoIP(Skype)</li>
</ul>

<h3 id="cs-vs-p2p">文件分布：C/S vs P2P</h3>

<p>在C/S架构下，上传下载数度有一个极限。</p>

<p>对于服务器来说，必须持续地上传N个文件副本。</p>

<ul>
  <li>传送一个副本：$F / u_s$</li>
  <li>传送多个副本：$NF / u_s$</li>
</ul>

<p>对于客户端来说，每个客户端都需要下载一份文件</p>

<p>最小下载时间： $F / d_{min}$</p>

<p>我们可以得到总时间为：</p>

<p>$ D<em>{c-s} \geq max \lbrace NF / u_s, F / d</em>{min} \rbrace $</p>

<p>其中N是线性增长的。</p>

<p>P2P架构下，服务器需要上传至少一个副本，客户端下载时间同上，对于多个分
布式系统而言，他们总共需要上传$NF$大小的文件量，最大上传速度为$u_s + \Sigma u_i$</p>

<p>总时间为：</p>

<p>$ D<em>{P2P} &gt;= max \lbrace F / u_s, F/d</em>{min}, NF / (u_s + \Sigma u_i) \rbrace $</p>

<p>N的线性增长在某种程度上被$\Sigma u_i$所抵消。</p>

<h3 id="bittorrent">BitTorrent协议</h3>

<p>文件被分割成256kb的小段，各个终端收发文件段。有一个追踪服务器来保存当
前参与torrent的终端的列表，当一个终端进入此网络时，它更新终端列表，
然后开始同这些终端交换文件段。一般而言，终端只跟总终端的某个子集(邻居)
进行文件交换。</p>

<p>刚进入网络的终端可能没有任何文件段，但是随着时间推移他会收到文件段直到完成传输。</p>

<p>请求文件段：</p>

<p>在任意给定的时间，不同的终端都有不同的文件子集。终端向其他终端请求传输
他们有的文件块，优先请求最珍稀的。</p>

<p>发送文件段：tit-for-tat</p>

<p>终端向正在给他发送文件段的4个终端以最高速度发送文件，每10秒钟重新计算最高速度的四个终端。
每30秒钟随机选择一个终端，开始发送文件段。</p>

 -->
    
        <p>关于应用层，最后一篇……終わった……小天使求治愈www</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io//computer%20science/network/transport_layer/" title="Transport Layer"><img src="http://MeowAlienOwO.github.io//images/2473257.jpg" alt="Transport Layer"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-15T21:00:24+08:00"><a href="http://MeowAlienOwO.github.io//computer%20science/network/transport_layer/">May 15, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io//about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io//computer%20science/network/transport_layer/" rel="bookmark" title="Transport Layer" itemprop="url">Transport Layer</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>传输层协议，看起来主要就是TCP的内容。单纵就是干！</p>

<h1 id="section">简介</h1>

<p>传输层协议主要提供了不同主机上的应用程序之间的交流能力。在终端主机上运
行。</p>

<p>发送者:将应用信息分段，传给网络层
接收者：将段重新汇编为信息，传给应用层</p>

<p>在因特网上，主要是TCP与UDP两种。</p>

<h1 id="tcpudp">TCP与UDP</h1>

<h2 id="user-datagram-protocaludp">用户数据报协议(User Datagram Protocal,UDP)</h2>

<p>IP上的很薄的一层。加入了校验和与包长度，用于防止包损坏；加入了源端口与
目标端口，用于可能的特殊应用。</p>

<p>UDP是不可靠的。</p>

<p>组成：
16比特源端口，16比特目标端口，16比特长度，16比特校验和。</p>

<h2 id="transmission-control-protoacal-tcp">传输控制协议(Transmission Control Protoacal, TCP)</h2>

<p>传输控制协议提供远比UDP可靠的通信手段。</p>

<p>连接使用三次握手方式创建，数据被操作系统分成包并且标号，接收包的时候要
返回已接收信息。连接必须被明确地关闭。</p>

<h3 id="section-1">七个主要特性</h3>

<ol>
  <li>面向连接</li>
  <li>点对点</li>
  <li>完全可信，接收的数据就是发送的数据</li>
  <li>完全双向通信</li>
  <li>流接口</li>
  <li>可靠的连接建立过程</li>
  <li>优雅的(……)关闭过程</li>
</ol>

<h3 id="section-2">建立链接</h3>

<p>使用特殊的同步(SYN)与结束(FIN)信息来打开/关闭连接，同时确认两边都接受
了所有的数据。</p>

<p>A      —SYN(SeqNo=x)—&gt;        B</p>

<p>&lt;—SYN(SeqNo=y, AckNo=x+1)—</p>

<p>—(SeqNo=x+1, AckNo=y+1)—&gt; </p>

<p>（看
<a href="http://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">维基</a>吧ppt实在太坑了……）</p>

<h3 id="section-3">传输信息</h3>

<p>维基的例子：</p>

<ol>
  <li>发送方首先发送第一个包含序列号为1（可变化）和1460字节数据的TCP报文段给接收方。接收方以一个没有数据的TCP报文段来回复（只含报头），用确认号1461来表示已完全收到并请求下一个报文段。</li>
  <li>发送方然后发送第二个包含序列号为1461和1460字节数据的TCP报文段给接收方。正常情况下，接收方以一个没有数据的TCP报文段来回复，用确认号2921（1461+1460）来表示已完全收到并请求下一个报文段。发送接收这样继续
下去。</li>
  <li>然而当这些数据包都是相连的情况下，接收方没有必要每一次都回应。比如，他收到第1到5条TCP报文段，只需回应第五条就行了。在例子中第3条TCP报文段被丢失了，所以尽管他收到了第4和5条，然而他只能回应第2条。</li>
  <li>发送方在发送了第三条以后，没能收到回应，因此当时钟（timer）过时（expire）时，他重发第三条。（每次发送者发送一条TCP报文段后，都会再次启动一次时钟：RTT）。</li>
  <li>这次第三条被成功接收，接收方可以直接确认第5条，因为4，5两条已收到。</li>
</ol>

<h3 id="section-4">关闭连接</h3>

<p>连接终止使用了四路握手过程（four-way handshake），在这个过程中每个终端的连接都能独立地被终止。因此，一个典型的拆接过程需要每个终端都提供一对FIN和ACK。</p>

<p>A  —FIN—&gt;  B</p>

<p>&lt;—ACK—</p>

<p>&lt;—FIN—</p>

<p>—ACK—&gt;</p>

<h1 id="tcp">TCP的可靠性机制</h1>

<h2 id="section-5">顺序</h2>

<p>动态路由可能会导致包并非顺序到达，TCP通过给予每个包一个序号来确保它们可以按顺序排列。这个序列号也可以用来侦测包的重复与缺失。</p>

<h2 id="section-6">重新传输</h2>

<p>发送方发送某个包后开始计时，如果超过一段时间没有得到响应则重发包。有一
定的尝试次数。接收方处理重复包。有的时候，在上一个会话的包会延迟抵达，
而此时下一个会话如果有相同的顺序号，就会出现重复问题，解决方案是同时标
记会话号。</p>

<h2 id="section-7">流控制</h2>

<p>数据超出往往在发送方传输速度大于接收方接受速度时发生。一个简单的方法是
在发送下一个之前对每个包进行接收通知(ack)，但是这个会带来带宽浪费。</p>

<p>TCP使用窗口机制。发送方与接收方约定一个窗口大小(包的数量)，在初始，一
整个窗口被发送，之后每个包被通知，然后另外一个才可以发送。接收方发送可
以接受的窗口大小。窗口大小为0则说明发送方需要在进一步的通知之前停止发
送。</p>

<p>TCP协议在工作时，如果发送端的TCP协议软件每传输一个数据分组后，必须等待接收端的确认才能够发送下一个分组，由于网络传输的时延，将有大量时间被用于等待确认，导致传输效率低下。为此TCP在进行数据传输时使用了滑动窗口机制。</p>

<p>TCP滑动窗口用来暂存两台计算机间要传送的数据分组。每台运行TCP协议的计算机有两个滑动窗口：一个用于数据发送，另一个用于数据接收。发送端待发数据分组在缓冲区排队等待送出。被滑动窗口框入的分组，是可以在未收到接收确认的情况下多送出的部分。滑动窗口左端标志X的分组，是已经被接收端确认收到的分组。随着新的确认到来，窗口不断向右滑动。</p>

<p>TCP协议软件依靠滑动窗口机制解决传输效率和流量控制问题。它可以在收到确认信息之前发送多个数据分组。这种机制使得网络通信处于忙碌状态，提高了整个网络的吞吐率，它还解决了端到端的通信流量控制问题，允许接收端在拥有容纳足够数据的缓冲之前对传输进行限制。在实际运行中，TCP滑动窗口的大小是可以随时调整的。收发端TCP协议软件在进行分组确认通信时，还交换滑动窗口控制信息，使得双方滑动窗口大小可以根据需要动态变化，达到在提高数据传输效率的同时，防止拥塞的发生。　称窗口左边沿向右边沿靠近为窗口合拢，这种现象发生在数据被发送和确认时。</p>

<p>当窗口右边沿向右移动时将允许发送更多的数据，称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时。</p>

<p>当右边沿向左移动时，称为窗口收缩。Host Requirements RFC强烈建议不要使用这种方式。但TCP必须能够在某一端产生这种情况时进行处理。
如果左边沿到达右边沿，则称其为一个零窗口。</p>

<ol>
  <li>发送方不必发送一个全窗口大小的数据。</li>
  <li>来自接收方的一个报文段确认数据并把窗口向右边滑动，这是因为窗口的大小是相对于确认序号的。</li>
  <li>窗口的大小可以减小，但是窗口的右边沿却不能够向左移动。</li>
  <li>接收方在发送一个ACK前不必等待窗口被填满。</li>
</ol>

<p>– 百度百科</p>

<h2 id="section-8">防止拥堵</h2>

<p>转换器信号与丢包都可以认为是网络拥堵的标志。TCP通过丢包来监控网络拥堵。对于第一个丢包，TCP将发送一个小信息。如果这个信息没有丢失，数据大小加倍，以此类推，直到窗口大小的一半，停止倍增。</p>
 -->
    
        <p>传输层协议，看起来主要就是TCP的内容。单纵就是干！</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io//computer%20science/network/network_layer/" title="Network Layer"><img src="http://MeowAlienOwO.github.io//images/50136576.jpg" alt="Network Layer"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-15T16:41:05+08:00"><a href="http://MeowAlienOwO.github.io//computer%20science/network/network_layer/">May 15, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io//about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io//computer%20science/network/network_layer/" rel="bookmark" title="Network Layer" itemprop="url">Network Layer</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>关于网络层的复习资料，T劣也要单纵干……听说放图能出船？总之捞到了云龙……</p>

<h1 id="internet-protocal">因特网协议(Internet Protocal)</h1>

<p>数据流被分成包，包含一个头部储存需要的信息；包在网络传输中是被单独传输的，因此，传输的方向性往往由头部决定。
网络节点有可能暂时储存包，当然包也有可能会丢失，损坏，乱序。在目标处，信息被重新构建。</p>

<p>同时，分包有如下好处：</p>

<ul>
  <li>数据传输是间歇性的</li>
  <li>不会浪费带宽</li>
  <li>容易多元化，不同的数据可以在同一个连接中传输</li>
  <li>包可以被几乎所有的载体输送</li>
</ul>

<p>当然，分包也带来了头部信息冗余的负担。</p>

<p>对于IP服务而言，它不需要提供一些额外的服务。</p>

<ul>
  <li>不需要错误检查/校正，这是其他层级的功能</li>
  <li>同一来源/同一数据源的包不一定遵循同一路径，只要包可以被顺利接受即可</li>
  <li>数据可以乱序输送，接收方负责将其重新排序</li>
  <li>包可以被丢失或者任意地延迟，接收方可以要求重新发包。</li>
  <li>没有对网络拥挤的控制，发送方可以减慢发送频率，延迟，或者丢包。</li>
</ul>

<h2 id="section">头部的格式</h2>

<p>在包中每32个比特作为一个单词(word)，包括头部跟数据。头部包含如下内容：</p>

<ul>
  <li>Version(4)，现在是4</li>
  <li>Hlen(4)，头部中32字节长度单词的数量</li>
  <li>TOS(8)，服务种类，不常用</li>
  <li>Length(16)，数据段(报文，datagram)中的字节数量</li>
  <li>Ident(16)，被分割所使用</li>
  <li>Flags/Offset(16)，同样是分割所用</li>
  <li>TTL(8)，生存时间</li>
  <li>Protocal(8)，协议种类，比如说TCP = 6,UDP = 17</li>
  <li>Checksum(16)，头部的校验和</li>
  <li>DestinationAddr &amp; SourceAddr(32)，源地址与目标地址</li>
</ul>

<p>括号内表示比特位数</p>

<h1 id="ip">IP地址</h1>

<h2 id="ipv4">IPv4</h2>
<p>每32比特地址被分成两个部分，分别是前缀与后缀。</p>

<ul>
  <li>前缀(prefix):表示主机的物理网络</li>
  <li>后缀(suffix):指定的物理网络的主机</li>
</ul>

<p>前缀同全球有关，而后缀同本地有关。</p>

<p>前/后缀的大小决定了网络的数量与某个特定网络的主机数量。同样，不同的前后缀长度也决定了不同的网络层级数量。
前四位的比特为决定了地址的层级。</p>

<p>我们通常使用点表达法来表示IP地址。
比如：
10000001 00110100 00000110 00000000 为 129.52.6.0</p>

<h3 id="section-1">五种层级</h3>

<ul>
  <li>A: 0+7位前缀+24位后缀</li>
  <li>B: 10+14位前缀+16位后缀</li>
  <li>C: 110+21位前缀+8位后缀</li>
  <li>D: 1110+多点传播地址</li>
  <li>E: 1111+储存供未来使用</li>
</ul>

<h3 id="classless-inter-domain-routing-cidr">无类别域间路由(Classless Inter-Domain Routing, CIDR)</h3>

<p>CIDR（无类别域间路由，Classless Inter-Domain Routing）是一个在Internet上创建附加地址的方法，这些地址提供给服务提供商（ISP），再由ISP分配给客户。CIDR将路由集中起来，使一个IP地址代表主要骨干提供商服务的几千个IP地址，从而减轻Internet路由器的负担。</p>

<p>获取前缀的方法，通常是将IP地址与子网掩码按位AND。</p>

<p>通过子网掩码，我们可以把一些路由字段给分配到同一个空间下，比如说100.100.1.1,100.100.2.1，使用子网掩码255.255.0.0，我们可以将其看作一个路由地址100.100.0.0，从而达到了扩展路由空间，减轻路由器负载的效果。</p>

<h2 id="section-2">32位地址的限制</h2>

<p>32位地址本身有着极大的限制，$2^32$只有大约4亿的数量，而某些地址又被使用在特殊范围,在当前不同移动设备乃至物联网入网的情况下，IP地址的数量远远不够。</p>

<p>短期解决方案：</p>

<ul>
  <li>Network Address Translation (NAT)</li>
  <li>Dynamically-assigned addresses(DHCP)</li>
</ul>

<p>长期解决方案：</p>

<p>使用IPv6标准扩展地址空间</p>

<h2 id="ipv6">IPv6</h2>

<p>IPv6同IPv4一样是无连接的，拥有128位地址大小。但是IPv6的地址模式有所不同，有单播(unicast)，复播(multicast)，从(cluster)等。</p>

<p>IPv6的头部是扩展的，并且拥有额外的安全性。</p>

<h2 id="fragmentation">分割(fragmentation)</h2>

<p>每一个网络都有一些最大传输单位(Maximum Transmission Unit, MTU)。 Ethernet：1500 FDDI：4500</p>

<p>当路由接受到一个大小大于最大传输单位的报文时，需要进行分割处理。
段(fragment)在接收主机进行重编译(reassembly)，而所有的段在Ident部分有着相同的区分标记。
段是自包含(self-contained)的数据包。同样的,IP也不检测丢失的段。</p>

<p>通过调整头部的偏移量(offset)以及记录开始的比特位来确定段的分割。</p>

<h2 id="dynamic-host-configuation-protocal-dhcp">动态主机配置协议(Dynamic Host Configuation Protocal, DHCP)</h2>

<p>特殊的DHCP服务器为主机分配IP地址</p>

<p>新登录的机器广播一个DHCP发现(DISCOVER)包，然后DHCP服务器返回一个IP地址。</p>

<h3 id="section-3">步骤：</h3>

<ol>
  <li>用户打开有DHCP客户端的机器，客户端机器广播一个DHCP DISCOVER包来寻找DHCP服务器，路由器将这个包传输到对应的DHCP服务器</li>
  <li>服务器接收到发现包，确定一个合适的地址，临时分配该地址给客户端。确定地之后，返回一个包含地址信息的OFFER包</li>
  <li>客户端发送REQUEST包，令服务器知道它要使用该地址</li>
  <li>服务器发送ACKNOWLEDGE包，确认该客户端可以在服务器所确定的时间内使用该地址</li>
</ol>

<h1 id="section-4">路由</h1>

<h2 id="forwarding-vs--routing">发送(Forwarding) vs 路由 (Routing)</h2>

<p>发送：</p>

<ul>
  <li>基于目标地址与路由表选择一个输出端口</li>
  <li>发送表的一行包含一个从网络数字(networking number)到输出接口的映射，同时也有一些MAC信息</li>
</ul>

<p>路由：</p>

<ul>
  <li>路由表是根据路由算法所构建的，作为发送表的准备</li>
  <li>一般来说包含从网络数字到下一个跳转的映射</li>
</ul>

<h3 id="section-5">计算路由表</h3>

<p>路由器需要知道如下两个东西：</p>

<ul>
  <li>哪个路由器来达到目标前缀</li>
  <li>哪个接口连接该路由器</li>
</ul>

<p>转换器解包到连接层，而路由器解压到网络层</p>

<p>路由算法往往是图的寻找任意两个节点之间的最短链接算法。
令c(x, y)为从节点x到y的成本，当他们不是邻居时，为无穷大</p>

<p>Dikstra算法， S是当前最短的路径，D(v)是从源地址到v的已知最短路径，C(w,v)是已知从w到v的成本
```python</p>

<p>Initialization:
  S = {u}
  for all nodes v
    if (v is adjacent to u)
      D(v) = c(u,v)
    else
      D(v) = infinity</p>

<p>Loop:Do
  find w not in s with the smallest D(w)
  add w to S
  update D(v) for all v adjacent to w and not in S:
    D(v) = min{D(v), D(w) + c(w,v)}
until all nodes in S</p>

<p>```</p>

<h2 id="link-state-routing">连接状态路由(link state routing)</h2>

<p>每个路由追踪它的对应的路由，包括路由是上/下，以及连接的成本；广播当前的连接状态；运行Dijkstra算法来计算最短路径并且创建发送表。</p>

<h3 id="bellman-ford">Bellman-Ford算法</h3>

<ol>
  <li>初始化：将除源点外的所有顶点的最短距离估计值 d[v] ←+∞, d[s] ←0;</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离；（运行</td>
          <td>v</td>
          <td>-1次）</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true，并且从源点可达的顶点v的最短距离保存在 d[v]中。 –百度百科</li>
</ol>

<p>松弛操作：</p>

<p>单源最短路径算法中使用了松弛（relaxation）操作。对于每个顶点v∈V，都设置一个属性d[v]，用来描述从源点s到v的最短路径上权值的上界，称为最短路径估计（shortest-path estimate）。</p>

<h2 id="distance-vector-routing">距离矢量路由(distance vector routing)</h2>

<p>每一个节点x维护如下状态：</p>

<p>c(x, v) = 从x到邻居v的直接连接成本
对于所有的节点y, 距离矢量Dx(y)（从x到y的最少成本）
对于所有的邻居节点，Dv(y)</p>

<p>节点x周期性的发送距离矢量Dx到邻居y，y据此更新他自己的距离矢量。</p>

<p>$Dv(y) = minx{c(v,x) + Dx(y)}}, for\ each\ node\ y \in N$</p>

<p>当要去节点m时，当前节点询问自己的邻居是否能达到m，当任意一节点收到询问请求时，检查自己的路由表，如果不能到达，同样询问邻居。
当有多个邻居返回时，取最小值。当自己的路由表根据以上信息更新时，通知自己的邻居。</p>
 -->
    
        <p>关于网络层的复习资料，T劣也要单纵干……听说放图能出船？总之捞到了云龙……</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io//computer%20science/network/link_layer/" title="Link Layer"><img src="http://MeowAlienOwO.github.io//images/50285937.jpg" alt="Link Layer"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-15T01:44:58+08:00"><a href="http://MeowAlienOwO.github.io//computer%20science/network/link_layer/">May 15, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io//about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io//computer%20science/network/link_layer/" rel="bookmark" title="Link Layer" itemprop="url">Link Layer</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>如你所见，还是复习资料……资源绝赞燃烧中，我要老李……</p>

<h1 id="section">简介与服务</h1>
<p>连接层，又称为数据链路层（Data Link），或称为网络介质层（Network
In-terface），也就是网络的基础建设，广泛应用于通信网的安全技术中，处理
通信与授权控制的核心协议。可在以太网（Ethernet）、光纤（Fiber）、无线
网络（Wireless）、帧传送（Frame Relay）或点对点（PPP）物理网络中为网络
层提供数据传送服务，连接层最重要的任务在于传送及接收物理层所传送的光电
信号。 –度娘</p>

<h2 id="section-1">连接层服务</h2>

<p>连接层包括如下服务：</p>

<h3 id="section-2">帧与链接入口</h3>
<p>数据包被封装成帧。加入了头部(header)跟追踪部(trailer)。同时，如果是共
享介质的话，还有信道入口的信息。MAC地址被用在帧头部来分别源地址与目标
地址。这同IP地址不同。</p>

<h3 id="relable-delivery-between-adjacent-nodes">相邻节点之间的可信传递(relable delivery between adjacent nodes)</h3>
<p>很少用于比特错误很少出现的链接，无线连接拥有更高的错误率。</p>

<h3 id="flow-control">流控制(flow control)</h3>
<p>决定相邻网络节点之间的传输速度</p>

<h3 id="error-detection">错误检测(error detection)</h3>
<p>错误由噪音与信号衰减所带来，接收方发现错误存在后或者请求重新传输，
或者直接丢失帧。</p>

<h3 id="error-correction">错误校正(error correction)</h3>
<p>接收方收到信息并且发现错误后，直接改正错误而不是请求重新传输或者丢包。</p>

<h3 id="section-3">双向传输与半双向传输</h3>
<p>半双向传输只能在某一时间传输一个方向，而双向传输可以同时传输两个方向</p>

<h2 id="section-4">连接层实现相关</h2>
<p>连接层被每个网络主机所实现，在接收机(adaptor)，或者说网路接口卡
(network interface card，NIC，网卡)或者芯片当中实现，比如以太网卡，
802.11卡。以太网芯片集等等。它通过主机系统，将一些硬件，软件与固件组
合起来。</p>

<h3 id="section-5">信息传输流程</h3>

<p>发送者：</p>

<ul>
  <li>将数据封装进帧</li>
  <li>加入错误校验位</li>
</ul>

<p>接收者：</p>

<ul>
  <li>寻找错误并作出处理</li>
  <li>解包，传递给接收的上一层处理</li>
</ul>

<h1 id="section-6">错误检测与校正</h1>

<h2 id="section-7">传输错误</h2>

<p>许多网络复杂度的增加由于接口的敏感性，而这些敏感性可以导致：</p>

<ul>
  <li>传输数据丢失或者改变</li>
  <li>出现随机数据</li>
</ul>

<h2 id="error-detection-1">错误检测(error detection)</h2>

<p>发送者包含一些额外的信息来总结原来的数据信息， 
接收者收到了数据以后检测这些额外的信息。之后，
接收者需要决定接下来是否要进行错误校正或者请求重新传输。</p>

<p>错误校验码：EDC = Error Detection(Correction) Bits</p>

<p>使用错误校验码并不是百分之百可靠的。</p>

<h3 id="parity-checking">奇偶校验位(parity checking)</h3>

<p>计算数据中1的数量，然后加入一个额外的比特位奇偶校验来进行奇偶校验。</p>

<p>该方法简单，但是只能检测很少的一部分错误。我们使用校验和(checksum)与循
环冗余校验码(cyclic redundancy checks)来进行检测。</p>

<h3 id="checksum">校验和(checksum)</h3>

<p>将数据分成若干个段，视之为整数，进行加和，储存结果。通常会使用16位与32
位校验和，而且通常对整个包进行校验和计算。</p>

<p>校验和通常会为数据增加16或者32位，而计算负荷只是简单的加法操作。相对的，
校验和有可能会存在一些未发现的错误。</p>

<h3 id="cyclic-redundancy-check">循环冗余检测(cyclic redundancy check)</h3>
<p>循环冗余检测比校验和更加强大，可以检测更多的错误，它是基于二进制除法的。</p>

<p>发送方希望发送$D$,一个长度为$d$的数据，发送与接收双方约定一个生成器
$G$,其长度为$r + 1$。</p>

<p>发送者在原有数据后加入一个$R$，使得$DR$恰好在二进制除法下被$G$所整除。
接收者进行反向操作并且检查余数是否为0。</p>

<h1 id="multiple-access-protocols">多址接入协议(Multiple Access Protocols)</h1>

<p>解决问题：</p>

<ul>
  <li>单个共享的广播信道</li>
  <li>两个或更多的节点同时进行传输活动，可能导致碰撞(collision)发生</li>
</ul>

<p>多址接入协议使用分布式算法来决定节点如何共享信道。</p>

<h2 id="section-8">一个理想的协议</h2>

<p>假设广播信道以$R$比特率进行传输。</p>

<p>理想方案是当一个节点希望传输时，它可以以$R$比特率传输。
当$M$个节点希望传输时，每个节点可以以平均$R/M$的比特率传输。
同时完全的去中心化：没有节点用来组织传输，不需要进行时钟同步/时间段同步等。</p>

<h2 id="mac">MAC协议</h2>

<h3 id="channel-partitioning">信道分配(channel partitioning)</h3>

<p>将信道分解为小的”碎片”(pieces)，比如时间段，频率，编码等等，将每个碎片
互斥地分配给节点。前述的FDM与TDM方法就属于这一种。</p>

<h3 id="random-access">随机接入(random access)</h3>

<p>不分解信道，允许碰撞发生，发生后从碰撞中恢复。</p>

<h3 id="taking-turns">轮流(“taking turns”)</h3>

<p>轮流方法指的是节点轮流占用信道，但是节点需要传输较长的信息可以使用更长
的时间。从中心站点得到权限，包括令牌(token)传输。</p>

<p>典型例子如蓝牙，FDDI，令牌环(token ring)等。</p>

<h2 id="csmacarrier-sence-multiple-access">载波侦听多路访问：CSMA(carrier sence multiple access)</h2>

<p>CSMA在传播之前监听：</p>

<ul>
  <li>如果信道空闲，则将整一帧传输；</li>
  <li>如果信道忙碌，则推迟传输。</li>
</ul>

<p>来自百度百科：
采用分布式控制方法，附接总线的各个结点通过竞争的方式，获得总线的使用权。
只有获得使用权的结点才可以向总线发送信息帧，该信息帧将被附接总线的所有结点感知。包括以下三个要点：载波侦听——发送结点在发送信息帧之前，必须侦听媒体是否处于空闲状态；多路访问——具有两种含义，既表示多个结点可以同时访问媒体，也表示一个结点发送的信息帧可以被多个结点所接收；冲突检测——发送结点在发出信息帧的同时，还必须监听媒体，判断是否发生冲突（同一时刻，有无其他结点也在发送信息帧）。IEEE 802.3或者OSI 8802/3定义了CSMA/CD的标准。</p>

<p>关于冲突检测：</p>

<p>b其概念时间模型分为三个时期：传输周期，竞争周期和空闲周期.
值得一提的是，监听的机制：传输数据时，他的硬件进行监听电缆，如果读回来的信息与发送的不一致，便知发送冲突了.这里，当然需要一种特殊的信号编码方案，能够检测出两个OV信号冲突.（或者在此冲突下，故意不检测，因信号没有损坏）
有线网中，冲突检测的最核心内容是 帧碎片（即检测到网络中有小于这个大小的帧就认为是帧碎片，因为传输2端都在传输造成冲突，2端数据在网络中都只有1部分，即不完整，产生碎片）。
在无线网中由于有隐藏结点（即每个结点不知道也不可能知道整个网络的实时情况），因此无法“检测”所以CSMA/CA（CSMA with Collision Avoidance）载波侦听多路访问冲突避免 就应运而生了，它是利用RTS/CTS（即类似TCP的握手协议)的应答策略来保证在传输中结点不会再接受请求，从而解决了无线网中的冲突。
总之：先听后发，边听边发，冲突不发，稍后再发</p>

<h3 id="csmacdcollision-detection">CSMA/CD(collision detection)</h3>

<p>CSMA依然会导致碰撞的发生：两个节点无法互相了解彼此的传输状态。</p>

<p>CSMA/CD用于有线传输。它可以在短时间内发现碰撞的产生并且阻止其传输，减
少了信道的浪费。</p>

<p>以太网的CSMA/CD算法：</p>

<ol>
  <li>网卡从网络层收到数据包，创建帧</li>
  <li>如果网卡检测到信道空闲，开始传输帧；如果检测到信道忙碌，等待直到信道空闲。</li>
  <li>如果网卡传输完毕整个帧而没有检测到碰撞，则传输完毕</li>
  <li>如果网卡检测到有碰撞发生，则停止传输并且发送阻塞信号(jam signal)</li>
  <li>当停止传输时，网卡使用二进制指数补偿方法:在第$m$个碰撞发生时，随机从
${2..2^m - 1}$中选取一个$k$，等待$K * 512$个比特时间，返回第二步。
显然的，碰撞越多，等待时间越长。</li>
</ol>

<h3 id="csmacacollision-avoidance">CSMA/CA(collision avoidance)</h3>

<h4 id="section-9">隐藏节点问题</h4>

<p>假设节点A,B,C，A与C只能向B进行信号传输。这意味着A与C不知道彼此之间的信
息。当A向B发送信息时，C的侦测认为BC是空闲的，于是C也发送信息。这时，碰
撞会在B节点发生，而A与C的碰撞检测全部失效。我们说这种情况下，A对C隐藏
(A is hidden for C)。</p>

<p>隐藏节点问题往往在无线网络通信中发生，需要在接收方进行载波检测。</p>

<p>“虚拟载波感应”(virtual carrier sensing)：发送者询问接收者是否能”听到”
别的节点发来的信息，如果是，则认为信道忙碌。</p>

<h4 id="csmaca">无线局域网与CSMA/CA</h4>

<p>由于无线网络的开放性，碰撞检测在这种环境下很容易失效。我们使用碰撞避免
方法来处理这种情况。发送方向接收方发送一个小型的请求信息，接收方向所有
的相邻节点返回一个”clear to send”信息。</p>

<h1 id="local-area-network-lan">局域网(Local Area Network, LAN)</h1>

<p>局域网（Local Area Network，LAN）是在一个局部的地理范围内（如一个学校、
工厂和机关内），一般是方圆几千米以内，将各种计算机，外部设备和数据库等
互相联接起来组成的计算机通信网。 – 百度百科</p>

<h2 id="section-10">寻址</h2>

<h3 id="mac-1">MAC地址</h3>

<p>在局域网中使用，用于从物理上相互连接的接口得到帧。通常而言，MAC地址为
48位，被烧录在NIC的ROM中，有的时候可以被软件所设置。</p>

<p>MAC地址被IEEE所管理，制造商购买一个特定的地址空间来保证元件的独特性。</p>

<p>同IP地址的关系：</p>

<p>MAC有独特性，而IP地址则是区域共享的。</p>

<h2 id="ethernet">以太网(Ethernet)</h2>

<p>以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网络使用CSMA/CD（载波监听多路访问及冲突检测）技术，并以10M/S的速率运行在多种类型的电缆上。以太网与IEEE802.3系列标准相类似。</p>

<p>以太网协议在网卡之间没有握手行为，所以是无连接(connectionless)的；接收方不返回”acks”/”nacks”给发送网卡，所以是不可靠(unreliable)的。丢失帧中的数据只在更高层级中规定了才恢复，否则数据就直接丢失。</p>

<p>以太网的MAC协议：无追踪的CSMA/CD，使用二进制补偿方法。</p>

<h3 id="section-11">物理拓扑</h3>

<p>总线型bus:在90年代中期比较流行，所有的节点在一个碰撞域之中(可以互相碰撞)。</p>

<p>星型star:现在比较常用，在中心有一个转换节点，每一个”辐条”(spoke)上运行一个独立的以太网协议，互相之间不发生碰撞。</p>

<h2 id="section-12">扩展</h2>
<p>### LAN的距离极限</p>

<p>MAC协议，比如CSMA/CD需要与导线长度成比例的时间;同时信号强度也会随着距离而衰减。</p>

<p>另外，网络设计者需要在一定的成本之下，考虑容量，延迟与距离的取舍。</p>

<h3 id="section-13">光纤的光学扩展</h3>

<p>光纤调制解调器可以在计算机与收发机之间扩展链接。</p>

<blockquote>
  <pre><code>                           收发机-&gt;Ethernet
                            ^  计算机-&gt;MODEM------------------MODEM
</code></pre>
</blockquote>

<h3 id="repeater">中继器(repeater)</h3>

<p>中继器将以太网段(segments)连接起来，它只放大信号强度，不关心帧信息。
中继器只处理信号强度，不处理延迟。光纤调制解调器可以在中继器与长距离扩展之间使用。</p>

<p>中继器的最大问题是，它会将错误与碰撞信号一起增强传输。</p>

<p>以太网标准规定在两个计算机之间不应有多于4个的中继器。</p>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>—R1—segment1,floor1—R4—segment2,floor1—</td>
      </tr>
      <tr>
        <td> </td>
      </tr>
      <tr>
        <td>—R2—segment1,floor2—R5—segment2,floor2—</td>
      </tr>
      <tr>
        <td> </td>
      </tr>
      <tr>
        <td>—R3—segment1,floor3—R6—segment2,floor3—</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h3 id="bridges">桥(bridges)</h3>

<p>桥可以将两个段之间连接起来，但是在帧层次使用。
使用混杂模式(promiscuous，真是个好词……)并且传送所有的帧。但是，错误帧，比如噪音与碰撞，例外。</p>

<p>一个例子：</p>

<blockquote>
  <p>——segment 1——Bridge——segment 2——
u v w                                    x y z</p>
</blockquote>

<table summary="段的例子">
<tr>
<th>事件</th>
<th>段1列表</th>
<th>段2列表</th>
</tr>

<tr>
<td>桥引导</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>u to v</td>
<td>u</td>
<td>-</td>
</tr>


<tr>
<td>v to u</td>
<td>u,v</td>
<td>-</td>
</tr>


<tr>
<td>z广播</td>
<td>u,v</td>
<td>z</td>
</tr>


<tr>
<td>y to v</td>
<td>u,v</td>
<td>z,y</td>
</tr>


<tr>
<td>y to x</td>
<td>u,b</td>
<td>z,y</td>
</tr>


<tr>
<td>x to w</td>
<td>u,v</td>
<td>z,y,x</td>
</tr>


<tr>
<td>w to z</td>
<td>u,v,w</td>
<td>z,y,x</td>
</tr>


</table>

<h4 id="frame-filtering">帧过滤(frame filtering)</h4>

<p>只有在需要传送帧的时候才是必要的。</p>

<ul>
  <li>目标是另一个段(segment)</li>
  <li>使用广播地址</li>
</ul>

<p>桥知道计算机在哪一段，并且知道帧发送的时间。</p>

<p>当帧到达桥时，解压缩源地址，更新信息，并且检查目标地址用于传输。</p>

<h3 id="switching">转换器(switching)</h3>

<p>一个简单的在计算机之间传送帧的电子设备。</p>

<p>鉴于集线器(hub)模拟了共享介质，转换器模拟了每个计算机一段的桥接的局域网。</p>

<p>好处在于由于平行，可以传送更大的数据量。有些情况下，使用集线器跟转换器来减少成本。</p>

 -->
    
        <p>如你所见，还是复习资料……资源绝赞燃烧中，我要老李……</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io//computer%20science/network/introduction_to_information_theory/" title="Introduction to Information Theory"><img src="http://MeowAlienOwO.github.io//images/49154861.jpg" alt="Introduction to Information Theory"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-14T23:23:43+08:00"><a href="http://MeowAlienOwO.github.io//computer%20science/network/introduction_to_information_theory/">May 14, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io//about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io//computer%20science/network/introduction_to_information_theory/" rel="bookmark" title="Introduction to Information Theory" itemprop="url">Introduction to Information Theory</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>肯德基居然打烊……说好的24小时呢……啊啊……好想给吃撑喂食play……(另外多少弹药可以钓一个打伞的大姐姐……)</p>

<h1 id="section">简介</h1>

<p>The fundamental problem of communication is that reproducing at one
point either exactly or approximately a message selected at another
point.</p>

<h1 id="section-1">信息熵与信息</h1>

<h2 id="section-2">信息冗余</h2>

<blockquote>
  <p>The quick brown fox jumps over the lazy dog</p>
</blockquote>

<p>这句句子中包含了所有的英文字母。我们可以很明显的看到其中有一些冗余字母，
比如说空格之类。移除所有空格可以使得我们依然能保持原有的意思，
但是移除所有的t,h,e字母则不行。这意味着，我们不能移除所有的冗余。</p>

<h2 id="section-3">熵</h2>

<p>我们使用熵(Entropy)来度量某个特殊的随机变量的平均不确定性。</p>

<p>在信息编码方面，熵用于度量描述一个随机变量的平均必须比特数量，
或者被认为是度量信息内容的量。</p>

<p>通常而言，熵可以表示表述一个随机变量所需平均比特数量的下界，
但是在实际的应用中，这往往无法实现。</p>

<p>计算公式：</p>

<p>$H(X) = - \Sigma_x p(x) \log_2 p(x)$</p>

<h2 id="bias">偏离(bias)</h2>

<p>当随机变量存在偏离时，熵的计算公式依然成立。比如在一个有8匹马参加的比赛中，
它们赢的概率分别为1/2, 1/4/, 1/8, 1/16, 1/64， 1/64。
熵值为2，这意味着我们仍然可以用平均长度为2的编码方法来编码所有的信息。</p>

<h2 id="section-4">霍夫曼编码</h2>

<h3 id="prefix-codes">前缀码(prefix codes)</h3>

<p>对于前缀码而言，没有任何元素可以成为另一个元素的开头。这导致了其的唯一性，也就是无歧义性。</p>

<p>霍夫曼编码是前缀码的一种。</p>

<h3 id="section-5">创建霍夫曼编码</h3>

<p>霍夫曼编码由符号的相对出现频率决定。霍夫曼算法可以保证平均符号长度的最优化。</p>

<blockquote>
  <p>例子：e 0.15, a 0.19, d 0.30, s 0.36</p>
</blockquote>

<p>将所有的未编码符号按照出现频率升序排列：</p>

<blockquote>
  <p>e a d s</p>
</blockquote>

<p>从小到大将两个频率之和相加直到和为1</p>

<blockquote>
  <p>e+a, (e+a)+d, ((e+a)+d)+s</p>
</blockquote>

<p>通过如上求和，构建霍夫曼树(可以看作构建语法树)</p>

<blockquote>
  <pre><code>         1 
         |
      s  +  0.64
              |
           d  +  0.34
                   |
                a  +  e
</code></pre>
</blockquote>

<p>从上到下，左边取0, 右边取1，最终编码为：</p>

<blockquote>
  <p>s 0
d 10
a 110
e 111</p>
</blockquote>
 -->
    
        <p>肯德基居然打烊……说好的24小时呢……啊啊……好想给吃撑喂食play……(另外多少弹药可以钓一个打伞的大姐姐……)</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->


<div class="pagination">
  
    Previous
  
  <ul class="inline-list">
    <li>
      
        <span class="current-page">1</span>
      
    </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io//page2">2</a>
        
      </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io//page3">3</a>
        
      </li>
    
  </ul>
  
    <a href="http://MeowAlienOwO.github.io//page2" class="btn">Next</a>
  
</div><!-- /.pagination -->

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2015 死鱼眼的喵星人. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="http://mademistakes.com/hpstr/" rel="notfollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://MeowAlienOwO.github.io//assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://MeowAlienOwO.github.io//assets/js/scripts.min.js"></script>




          

</body>
</html>
