<!doctype html lang="zh">
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Entry &#8211; 喵窝[0]号机</title>
<meta name="description" content="一个伪装成技术博客的吐槽网站。">

<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- other plugins config -->
<!-- mathjax -->
<script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$'], [ '\\(', '\\)']]}});
</script>

<!-- Share.js -->
<link href="/assets/css/share.min.css" rel="stylesheet">
<script type="text/javascript" src="/assets/js/vendor/share.min.js"></script>
<!-- end of plugins -->

<meta http-equiv="content-type" content="text/html; charset=utf-8" />


<!-- Open Graph -->
<!-- <meta property="og:locale" content="en_US"> -->
<meta property="og:locale" content="zh_CN" />
<meta property="og:type" content="article">
<meta property="og:title" content="Entry">
<meta property="og:description" content="一个伪装成技术博客的吐槽网站。">
<meta property="og:url" content="http://MeowAlienOwO.github.io/page5/">
<meta property="og:site_name" content="喵窝[0]号机">





<link rel="canonical" href="http://MeowAlienOwO.github.io/page5/">
<link href="http://MeowAlienOwO.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="喵窝[0]号机 Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://MeowAlienOwO.github.io/assets/css/main.css">
<!-- Webfonts -->
<link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">
<!--
     <link href="//fonts.useso.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css"> -->

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://MeowAlienOwO.github.io/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://MeowAlienOwO.github.io/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://MeowAlienOwO.github.io/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://MeowAlienOwO.github.io/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://MeowAlienOwO.github.io/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://MeowAlienOwO.github.io/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://MeowAlienOwO.github.io/images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://MeowAlienOwO.github.io/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://MeowAlienOwO.github.io/images/avatar.png" alt="死鱼眼的喵星人 photo" class="author-photo">
					<h4>死鱼眼的喵星人</h4>
					<p>烈風？いいえ、知らない子ですね。（もぐもぐ</p>

				</li>
				<li><a href="http://MeowAlienOwO.github.io/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:meowalienowo@outlook.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				
				
				
				
				<li>
					<a href="http://github.com/https://github.com/MeowAlienOwO"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://MeowAlienOwO.github.io/posts/">All Posts</a></li>
				<li><a href="http://MeowAlienOwO.github.io/tags/">All Tags</a></li>
				
				<li>
				  <a href="/categories/Life/">
				    Life (7)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Computer Science/">
				    Computer Science (19)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Software Engineering/">
				    Software Engineering (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Japanese/">
				    Japanese (2)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Machine Learning/">
				    Machine Learning (2)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/math/">
				    math (1)
				  </a>
				</li>
				
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  <div class="image-credit">Image source: <a href="http://www.pixiv.net/member_illust.php?mode=medium&illust_id=22958285">ZERO | STAR影法師 [pixiv]</a></div><!-- /.image-credit -->
  
    <div class="entry-image">
      <img src="http://MeowAlienOwO.github.io/images/22958285.jpg" alt="Entry">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>喵窝[0]号机</h1>
      <h2>一个伪装成技术博客的吐槽网站。</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/computer%20science/network_layer/" title="Network Layer">
            
            <img src="http://MeowAlienOwO.github.io/images/50136576.jpg" alt="Network Layer">
            
        </a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-15T16:41:05+08:00"><a href="http://MeowAlienOwO.github.io/computer%20science/network_layer/">May 15, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/computer%20science/network_layer/" rel="bookmark" title="Network Layer" itemprop="url">Network Layer</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>关于网络层的复习资料，T劣也要单纵干……听说放图能出船？总之捞到了云龙……</p>

<h1 id="因特网协议internet-protocal">因特网协议(Internet Protocal)</h1>

<p>数据流被分成包，包含一个头部储存需要的信息；包在网络传输中是被单独传输的，因此，传输的方向性往往由头部决定。
网络节点有可能暂时储存包，当然包也有可能会丢失，损坏，乱序。在目标处，信息被重新构建。</p>

<p>同时，分包有如下好处：</p>

<ul>
  <li>数据传输是间歇性的</li>
  <li>不会浪费带宽</li>
  <li>容易多元化，不同的数据可以在同一个连接中传输</li>
  <li>包可以被几乎所有的载体输送</li>
</ul>

<p>当然，分包也带来了头部信息冗余的负担。</p>

<p>对于IP服务而言，它不需要提供一些额外的服务。</p>

<ul>
  <li>不需要错误检查/校正，这是其他层级的功能</li>
  <li>同一来源/同一数据源的包不一定遵循同一路径，只要包可以被顺利接受即可</li>
  <li>数据可以乱序输送，接收方负责将其重新排序</li>
  <li>包可以被丢失或者任意地延迟，接收方可以要求重新发包。</li>
  <li>没有对网络拥挤的控制，发送方可以减慢发送频率，延迟，或者丢包。</li>
</ul>

<h2 id="头部的格式">头部的格式</h2>

<p>在包中每32个比特作为一个单词(word)，包括头部跟数据。头部包含如下内容：</p>

<ul>
  <li>Version(4)，现在是4</li>
  <li>Hlen(4)，头部中32字节长度单词的数量</li>
  <li>TOS(8)，服务种类，不常用</li>
  <li>Length(16)，数据段(报文，datagram)中的字节数量</li>
  <li>Ident(16)，被分割所使用</li>
  <li>Flags/Offset(16)，同样是分割所用</li>
  <li>TTL(8)，生存时间</li>
  <li>Protocal(8)，协议种类，比如说TCP = 6,UDP = 17</li>
  <li>Checksum(16)，头部的校验和</li>
  <li>DestinationAddr &amp; SourceAddr(32)，源地址与目标地址</li>
</ul>

<p>括号内表示比特位数</p>

<h1 id="ip地址">IP地址</h1>

<h2 id="ipv4">IPv4</h2>
<p>每32比特地址被分成两个部分，分别是前缀与后缀。</p>

<ul>
  <li>前缀(prefix):表示主机的物理网络</li>
  <li>后缀(suffix):指定的物理网络的主机</li>
</ul>

<p>前缀同全球有关，而后缀同本地有关。</p>

<p>前/后缀的大小决定了网络的数量与某个特定网络的主机数量。同样，不同的前后缀长度也决定了不同的网络层级数量。
前四位的比特为决定了地址的层级。</p>

<p>我们通常使用点表达法来表示IP地址。
比如：
10000001 00110100 00000110 00000000 为 129.52.6.0</p>

<h3 id="五种层级">五种层级</h3>

<ul>
  <li>A: 0+7位前缀+24位后缀</li>
  <li>B: 10+14位前缀+16位后缀</li>
  <li>C: 110+21位前缀+8位后缀</li>
  <li>D: 1110+多点传播地址</li>
  <li>E: 1111+储存供未来使用</li>
</ul>

<h3 id="无类别域间路由classless-inter-domain-routing-cidr">无类别域间路由(Classless Inter-Domain Routing, CIDR)</h3>

<p>CIDR（无类别域间路由，Classless Inter-Domain Routing）是一个在Internet上创建附加地址的方法，这些地址提供给服务提供商（ISP），再由ISP分配给客户。CIDR将路由集中起来，使一个IP地址代表主要骨干提供商服务的几千个IP地址，从而减轻Internet路由器的负担。</p>

<p>获取前缀的方法，通常是将IP地址与子网掩码按位AND。</p>

<p>通过子网掩码，我们可以把一些路由字段给分配到同一个空间下，比如说100.100.1.1,100.100.2.1，使用子网掩码255.255.0.0，我们可以将其看作一个路由地址100.100.0.0，从而达到了扩展路由空间，减轻路由器负载的效果。</p>

<h2 id="32位地址的限制">32位地址的限制</h2>

<p>32位地址本身有着极大的限制，$2^32$只有大约4亿的数量，而某些地址又被使用在特殊范围,在当前不同移动设备乃至物联网入网的情况下，IP地址的数量远远不够。</p>

<p>短期解决方案：</p>

<ul>
  <li>Network Address Translation (NAT)</li>
  <li>Dynamically-assigned addresses(DHCP)</li>
</ul>

<p>长期解决方案：</p>

<p>使用IPv6标准扩展地址空间</p>

<h2 id="ipv6">IPv6</h2>

<p>IPv6同IPv4一样是无连接的，拥有128位地址大小。但是IPv6的地址模式有所不同，有单播(unicast)，复播(multicast)，从(cluster)等。</p>

<p>IPv6的头部是扩展的，并且拥有额外的安全性。</p>

<h2 id="分割fragmentation">分割(fragmentation)</h2>

<p>每一个网络都有一些最大传输单位(Maximum Transmission Unit, MTU)。 Ethernet：1500 FDDI：4500</p>

<p>当路由接受到一个大小大于最大传输单位的报文时，需要进行分割处理。
段(fragment)在接收主机进行重编译(reassembly)，而所有的段在Ident部分有着相同的区分标记。
段是自包含(self-contained)的数据包。同样的,IP也不检测丢失的段。</p>

<p>通过调整头部的偏移量(offset)以及记录开始的比特位来确定段的分割。</p>

<h2 id="动态主机配置协议dynamic-host-configuation-protocal-dhcp">动态主机配置协议(Dynamic Host Configuation Protocal, DHCP)</h2>

<p>特殊的DHCP服务器为主机分配IP地址</p>

<p>新登录的机器广播一个DHCP发现(DISCOVER)包，然后DHCP服务器返回一个IP地址。</p>

<h3 id="步骤">步骤：</h3>

<ol>
  <li>用户打开有DHCP客户端的机器，客户端机器广播一个DHCP DISCOVER包来寻找DHCP服务器，路由器将这个包传输到对应的DHCP服务器</li>
  <li>服务器接收到发现包，确定一个合适的地址，临时分配该地址给客户端。确定地之后，返回一个包含地址信息的OFFER包</li>
  <li>客户端发送REQUEST包，令服务器知道它要使用该地址</li>
  <li>服务器发送ACKNOWLEDGE包，确认该客户端可以在服务器所确定的时间内使用该地址</li>
</ol>

<h1 id="路由">路由</h1>

<h2 id="发送forwarding-vs-路由-routing">发送(Forwarding) vs 路由 (Routing)</h2>

<p>发送：</p>

<ul>
  <li>基于目标地址与路由表选择一个输出端口</li>
  <li>发送表的一行包含一个从网络数字(networking number)到输出接口的映射，同时也有一些MAC信息</li>
</ul>

<p>路由：</p>

<ul>
  <li>路由表是根据路由算法所构建的，作为发送表的准备</li>
  <li>一般来说包含从网络数字到下一个跳转的映射</li>
</ul>

<h3 id="计算路由表">计算路由表</h3>

<p>路由器需要知道如下两个东西：</p>

<ul>
  <li>哪个路由器来达到目标前缀</li>
  <li>哪个接口连接该路由器</li>
</ul>

<p>转换器解包到连接层，而路由器解压到网络层</p>

<p>路由算法往往是图的寻找任意两个节点之间的最短链接算法。
令c(x, y)为从节点x到y的成本，当他们不是邻居时，为无穷大</p>

<p>Dikstra算法， S是当前最短的路径，D(v)是从源地址到v的已知最短路径，C(w,v)是已知从w到v的成本</p>
<pre><code class="language-python">
Initialization:
  S = {u}
  for all nodes v
    if (v is adjacent to u)
      D(v) = c(u,v)
    else
      D(v) = infinity

Loop:Do
  find w not in s with the smallest D(w)
  add w to S
  update D(v) for all v adjacent to w and not in S:
    D(v) = min{D(v), D(w) + c(w,v)}
until all nodes in S

</code></pre>

<h2 id="连接状态路由link-state-routing">连接状态路由(link state routing)</h2>

<p>每个路由追踪它的对应的路由，包括路由是上/下，以及连接的成本；广播当前的连接状态；运行Dijkstra算法来计算最短路径并且创建发送表。</p>

<h3 id="bellman-ford算法">Bellman-Ford算法</h3>

<ol>
  <li>初始化：将除源点外的所有顶点的最短距离估计值 d[v] ←+∞, d[s] ←0;</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离；（运行</td>
          <td>v</td>
          <td>-1次）</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true，并且从源点可达的顶点v的最短距离保存在 d[v]中。 –百度百科</li>
</ol>

<p>松弛操作：</p>

<p>单源最短路径算法中使用了松弛（relaxation）操作。对于每个顶点v∈V，都设置一个属性d[v]，用来描述从源点s到v的最短路径上权值的上界，称为最短路径估计（shortest-path estimate）。</p>

<h2 id="距离矢量路由distance-vector-routing">距离矢量路由(distance vector routing)</h2>

<p>每一个节点x维护如下状态：</p>

<p>c(x, v) = 从x到邻居v的直接连接成本
对于所有的节点y, 距离矢量Dx(y)（从x到y的最少成本）
对于所有的邻居节点，Dv(y)</p>

<p>节点x周期性的发送距离矢量Dx到邻居y，y据此更新他自己的距离矢量。</p>

<p>$Dv(y) = minx{c(v,x) + Dx(y)}}, for\ each\ node\ y \in N$</p>

<p>当要去节点m时，当前节点询问自己的邻居是否能达到m，当任意一节点收到询问请求时，检查自己的路由表，如果不能到达，同样询问邻居。
当有多个邻居返回时，取最小值。当自己的路由表根据以上信息更新时，通知自己的邻居。</p>
 -->
    
        <p>关于网络层的复习资料，T劣也要单纵干……听说放图能出船？总之捞到了云龙……</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/computer%20science/link_layer/" title="Link Layer">
            
            <img src="http://MeowAlienOwO.github.io/images/50285937.jpg" alt="Link Layer">
            
        </a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-15T01:44:58+08:00"><a href="http://MeowAlienOwO.github.io/computer%20science/link_layer/">May 15, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/computer%20science/link_layer/" rel="bookmark" title="Link Layer" itemprop="url">Link Layer</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>如你所见，还是复习资料……资源绝赞燃烧中，我要老李……</p>

<h1 id="简介与服务">简介与服务</h1>
<p>连接层，又称为数据链路层（Data Link），或称为网络介质层（Network
In-terface），也就是网络的基础建设，广泛应用于通信网的安全技术中，处理
通信与授权控制的核心协议。可在以太网（Ethernet）、光纤（Fiber）、无线
网络（Wireless）、帧传送（Frame Relay）或点对点（PPP）物理网络中为网络
层提供数据传送服务，连接层最重要的任务在于传送及接收物理层所传送的光电
信号。 –度娘</p>

<h2 id="连接层服务">连接层服务</h2>

<p>连接层包括如下服务：</p>

<h3 id="帧与链接入口">帧与链接入口</h3>
<p>数据包被封装成帧。加入了头部(header)跟追踪部(trailer)。同时，如果是共
享介质的话，还有信道入口的信息。MAC地址被用在帧头部来分别源地址与目标
地址。这同IP地址不同。</p>

<h3 id="相邻节点之间的可信传递relable-delivery-between-adjacent-nodes">相邻节点之间的可信传递(relable delivery between adjacent nodes)</h3>
<p>很少用于比特错误很少出现的链接，无线连接拥有更高的错误率。</p>

<h3 id="流控制flow-control">流控制(flow control)</h3>
<p>决定相邻网络节点之间的传输速度</p>

<h3 id="错误检测error-detection">错误检测(error detection)</h3>
<p>错误由噪音与信号衰减所带来，接收方发现错误存在后或者请求重新传输，
或者直接丢失帧。</p>

<h3 id="错误校正error-correction">错误校正(error correction)</h3>
<p>接收方收到信息并且发现错误后，直接改正错误而不是请求重新传输或者丢包。</p>

<h3 id="双向传输与半双向传输">双向传输与半双向传输</h3>
<p>半双向传输只能在某一时间传输一个方向，而双向传输可以同时传输两个方向</p>

<h2 id="连接层实现相关">连接层实现相关</h2>
<p>连接层被每个网络主机所实现，在接收机(adaptor)，或者说网路接口卡
(network interface card，NIC，网卡)或者芯片当中实现，比如以太网卡，
802.11卡。以太网芯片集等等。它通过主机系统，将一些硬件，软件与固件组
合起来。</p>

<h3 id="信息传输流程">信息传输流程</h3>

<p>发送者：</p>

<ul>
  <li>将数据封装进帧</li>
  <li>加入错误校验位</li>
</ul>

<p>接收者：</p>

<ul>
  <li>寻找错误并作出处理</li>
  <li>解包，传递给接收的上一层处理</li>
</ul>

<h1 id="错误检测与校正">错误检测与校正</h1>

<h2 id="传输错误">传输错误</h2>

<p>许多网络复杂度的增加由于接口的敏感性，而这些敏感性可以导致：</p>

<ul>
  <li>传输数据丢失或者改变</li>
  <li>出现随机数据</li>
</ul>

<h2 id="错误检测error-detection-1">错误检测(error detection)</h2>

<p>发送者包含一些额外的信息来总结原来的数据信息， 
接收者收到了数据以后检测这些额外的信息。之后，
接收者需要决定接下来是否要进行错误校正或者请求重新传输。</p>

<p>错误校验码：EDC = Error Detection(Correction) Bits</p>

<p>使用错误校验码并不是百分之百可靠的。</p>

<h3 id="奇偶校验位parity-checking">奇偶校验位(parity checking)</h3>

<p>计算数据中1的数量，然后加入一个额外的比特位奇偶校验来进行奇偶校验。</p>

<p>该方法简单，但是只能检测很少的一部分错误。我们使用校验和(checksum)与循
环冗余校验码(cyclic redundancy checks)来进行检测。</p>

<h3 id="校验和checksum">校验和(checksum)</h3>

<p>将数据分成若干个段，视之为整数，进行加和，储存结果。通常会使用16位与32
位校验和，而且通常对整个包进行校验和计算。</p>

<p>校验和通常会为数据增加16或者32位，而计算负荷只是简单的加法操作。相对的，
校验和有可能会存在一些未发现的错误。</p>

<h3 id="循环冗余检测cyclic-redundancy-check">循环冗余检测(cyclic redundancy check)</h3>
<p>循环冗余检测比校验和更加强大，可以检测更多的错误，它是基于二进制除法的。</p>

<p>发送方希望发送$D$,一个长度为$d$的数据，发送与接收双方约定一个生成器
$G$,其长度为$r + 1$。</p>

<p>发送者在原有数据后加入一个$R$，使得$DR$恰好在二进制除法下被$G$所整除。
接收者进行反向操作并且检查余数是否为0。</p>

<h1 id="多址接入协议multiple-access-protocols">多址接入协议(Multiple Access Protocols)</h1>

<p>解决问题：</p>

<ul>
  <li>单个共享的广播信道</li>
  <li>两个或更多的节点同时进行传输活动，可能导致碰撞(collision)发生</li>
</ul>

<p>多址接入协议使用分布式算法来决定节点如何共享信道。</p>

<h2 id="一个理想的协议">一个理想的协议</h2>

<p>假设广播信道以$R$比特率进行传输。</p>

<p>理想方案是当一个节点希望传输时，它可以以$R$比特率传输。
当$M$个节点希望传输时，每个节点可以以平均$R/M$的比特率传输。
同时完全的去中心化：没有节点用来组织传输，不需要进行时钟同步/时间段同步等。</p>

<h2 id="mac协议">MAC协议</h2>

<h3 id="信道分配channel-partitioning">信道分配(channel partitioning)</h3>

<p>将信道分解为小的”碎片”(pieces)，比如时间段，频率，编码等等，将每个碎片
互斥地分配给节点。前述的FDM与TDM方法就属于这一种。</p>

<h3 id="随机接入random-access">随机接入(random access)</h3>

<p>不分解信道，允许碰撞发生，发生后从碰撞中恢复。</p>

<h3 id="轮流taking-turns">轮流(“taking turns”)</h3>

<p>轮流方法指的是节点轮流占用信道，但是节点需要传输较长的信息可以使用更长
的时间。从中心站点得到权限，包括令牌(token)传输。</p>

<p>典型例子如蓝牙，FDDI，令牌环(token ring)等。</p>

<h2 id="载波侦听多路访问csmacarrier-sence-multiple-access">载波侦听多路访问：CSMA(carrier sence multiple access)</h2>

<p>CSMA在传播之前监听：</p>

<ul>
  <li>如果信道空闲，则将整一帧传输；</li>
  <li>如果信道忙碌，则推迟传输。</li>
</ul>

<p>来自百度百科：
采用分布式控制方法，附接总线的各个结点通过竞争的方式，获得总线的使用权。
只有获得使用权的结点才可以向总线发送信息帧，该信息帧将被附接总线的所有结点感知。包括以下三个要点：载波侦听——发送结点在发送信息帧之前，必须侦听媒体是否处于空闲状态；多路访问——具有两种含义，既表示多个结点可以同时访问媒体，也表示一个结点发送的信息帧可以被多个结点所接收；冲突检测——发送结点在发出信息帧的同时，还必须监听媒体，判断是否发生冲突（同一时刻，有无其他结点也在发送信息帧）。IEEE 802.3或者OSI 8802/3定义了CSMA/CD的标准。</p>

<p>关于冲突检测：</p>

<p>b其概念时间模型分为三个时期：传输周期，竞争周期和空闲周期.
值得一提的是，监听的机制：传输数据时，他的硬件进行监听电缆，如果读回来的信息与发送的不一致，便知发送冲突了.这里，当然需要一种特殊的信号编码方案，能够检测出两个OV信号冲突.（或者在此冲突下，故意不检测，因信号没有损坏）
有线网中，冲突检测的最核心内容是 帧碎片（即检测到网络中有小于这个大小的帧就认为是帧碎片，因为传输2端都在传输造成冲突，2端数据在网络中都只有1部分，即不完整，产生碎片）。
在无线网中由于有隐藏结点（即每个结点不知道也不可能知道整个网络的实时情况），因此无法“检测”所以CSMA/CA（CSMA with Collision Avoidance）载波侦听多路访问冲突避免 就应运而生了，它是利用RTS/CTS（即类似TCP的握手协议)的应答策略来保证在传输中结点不会再接受请求，从而解决了无线网中的冲突。
总之：先听后发，边听边发，冲突不发，稍后再发</p>

<h3 id="csmacdcollision-detection">CSMA/CD(collision detection)</h3>

<p>CSMA依然会导致碰撞的发生：两个节点无法互相了解彼此的传输状态。</p>

<p>CSMA/CD用于有线传输。它可以在短时间内发现碰撞的产生并且阻止其传输，减
少了信道的浪费。</p>

<p>以太网的CSMA/CD算法：</p>

<ol>
  <li>网卡从网络层收到数据包，创建帧</li>
  <li>如果网卡检测到信道空闲，开始传输帧；如果检测到信道忙碌，等待直到信道空闲。</li>
  <li>如果网卡传输完毕整个帧而没有检测到碰撞，则传输完毕</li>
  <li>如果网卡检测到有碰撞发生，则停止传输并且发送阻塞信号(jam signal)</li>
  <li>当停止传输时，网卡使用二进制指数补偿方法:在第$m$个碰撞发生时，随机从
${2..2^m - 1}$中选取一个$k$，等待$K * 512$个比特时间，返回第二步。
显然的，碰撞越多，等待时间越长。</li>
</ol>

<h3 id="csmacacollision-avoidance">CSMA/CA(collision avoidance)</h3>

<h4 id="隐藏节点问题">隐藏节点问题</h4>

<p>假设节点A,B,C，A与C只能向B进行信号传输。这意味着A与C不知道彼此之间的信
息。当A向B发送信息时，C的侦测认为BC是空闲的，于是C也发送信息。这时，碰
撞会在B节点发生，而A与C的碰撞检测全部失效。我们说这种情况下，A对C隐藏
(A is hidden for C)。</p>

<p>隐藏节点问题往往在无线网络通信中发生，需要在接收方进行载波检测。</p>

<p>“虚拟载波感应”(virtual carrier sensing)：发送者询问接收者是否能”听到”
别的节点发来的信息，如果是，则认为信道忙碌。</p>

<h4 id="无线局域网与csmaca">无线局域网与CSMA/CA</h4>

<p>由于无线网络的开放性，碰撞检测在这种环境下很容易失效。我们使用碰撞避免
方法来处理这种情况。发送方向接收方发送一个小型的请求信息，接收方向所有
的相邻节点返回一个”clear to send”信息。</p>

<h1 id="局域网local-area-network-lan">局域网(Local Area Network, LAN)</h1>

<p>局域网（Local Area Network，LAN）是在一个局部的地理范围内（如一个学校、
工厂和机关内），一般是方圆几千米以内，将各种计算机，外部设备和数据库等
互相联接起来组成的计算机通信网。 – 百度百科</p>

<h2 id="寻址">寻址</h2>

<h3 id="mac地址">MAC地址</h3>

<p>在局域网中使用，用于从物理上相互连接的接口得到帧。通常而言，MAC地址为
48位，被烧录在NIC的ROM中，有的时候可以被软件所设置。</p>

<p>MAC地址被IEEE所管理，制造商购买一个特定的地址空间来保证元件的独特性。</p>

<p>同IP地址的关系：</p>

<p>MAC有独特性，而IP地址则是区域共享的。</p>

<h2 id="以太网ethernet">以太网(Ethernet)</h2>

<p>以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网络使用CSMA/CD（载波监听多路访问及冲突检测）技术，并以10M/S的速率运行在多种类型的电缆上。以太网与IEEE802.3系列标准相类似。</p>

<p>以太网协议在网卡之间没有握手行为，所以是无连接(connectionless)的；接收方不返回”acks”/”nacks”给发送网卡，所以是不可靠(unreliable)的。丢失帧中的数据只在更高层级中规定了才恢复，否则数据就直接丢失。</p>

<p>以太网的MAC协议：无追踪的CSMA/CD，使用二进制补偿方法。</p>

<h3 id="物理拓扑">物理拓扑</h3>

<p>总线型bus:在90年代中期比较流行，所有的节点在一个碰撞域之中(可以互相碰撞)。</p>

<p>星型star:现在比较常用，在中心有一个转换节点，每一个”辐条”(spoke)上运行一个独立的以太网协议，互相之间不发生碰撞。</p>

<h2 id="扩展">扩展</h2>
<h3 id="lan的距离极限">LAN的距离极限</h3>

<p>MAC协议，比如CSMA/CD需要与导线长度成比例的时间;同时信号强度也会随着距离而衰减。</p>

<p>另外，网络设计者需要在一定的成本之下，考虑容量，延迟与距离的取舍。</p>

<h3 id="光纤的光学扩展">光纤的光学扩展</h3>

<p>光纤调制解调器可以在计算机与收发机之间扩展链接。</p>

<blockquote>
  <pre><code>                           收发机-&gt;Ethernet
                            ^  计算机-&gt;MODEM------------------MODEM
</code></pre>
</blockquote>

<h3 id="中继器repeater">中继器(repeater)</h3>

<p>中继器将以太网段(segments)连接起来，它只放大信号强度，不关心帧信息。
中继器只处理信号强度，不处理延迟。光纤调制解调器可以在中继器与长距离扩展之间使用。</p>

<p>中继器的最大问题是，它会将错误与碰撞信号一起增强传输。</p>

<p>以太网标准规定在两个计算机之间不应有多于4个的中继器。</p>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>—R1—segment1,floor1—R4—segment2,floor1—</td>
      </tr>
      <tr>
        <td> </td>
      </tr>
      <tr>
        <td>—R2—segment1,floor2—R5—segment2,floor2—</td>
      </tr>
      <tr>
        <td> </td>
      </tr>
      <tr>
        <td>—R3—segment1,floor3—R6—segment2,floor3—</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h3 id="桥bridges">桥(bridges)</h3>

<p>桥可以将两个段之间连接起来，但是在帧层次使用。
使用混杂模式(promiscuous，真是个好词……)并且传送所有的帧。但是，错误帧，比如噪音与碰撞，例外。</p>

<p>一个例子：</p>

<blockquote>
  <p>——segment 1——Bridge——segment 2——
u v w                                    x y z</p>
</blockquote>

<table summary="段的例子">
<tr>
<th>事件</th>
<th>段1列表</th>
<th>段2列表</th>
</tr>

<tr>
<td>桥引导</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>u to v</td>
<td>u</td>
<td>-</td>
</tr>


<tr>
<td>v to u</td>
<td>u,v</td>
<td>-</td>
</tr>


<tr>
<td>z广播</td>
<td>u,v</td>
<td>z</td>
</tr>


<tr>
<td>y to v</td>
<td>u,v</td>
<td>z,y</td>
</tr>


<tr>
<td>y to x</td>
<td>u,b</td>
<td>z,y</td>
</tr>


<tr>
<td>x to w</td>
<td>u,v</td>
<td>z,y,x</td>
</tr>


<tr>
<td>w to z</td>
<td>u,v,w</td>
<td>z,y,x</td>
</tr>


</table>

<h4 id="帧过滤frame-filtering">帧过滤(frame filtering)</h4>

<p>只有在需要传送帧的时候才是必要的。</p>

<ul>
  <li>目标是另一个段(segment)</li>
  <li>使用广播地址</li>
</ul>

<p>桥知道计算机在哪一段，并且知道帧发送的时间。</p>

<p>当帧到达桥时，解压缩源地址，更新信息，并且检查目标地址用于传输。</p>

<h3 id="转换器switching">转换器(switching)</h3>

<p>一个简单的在计算机之间传送帧的电子设备。</p>

<p>鉴于集线器(hub)模拟了共享介质，转换器模拟了每个计算机一段的桥接的局域网。</p>

<p>好处在于由于平行，可以传送更大的数据量。有些情况下，使用集线器跟转换器来减少成本。</p>

 -->
    
        <p>如你所见，还是复习资料……资源绝赞燃烧中，我要老李……</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/computer%20science/introduction_to_information_theory/" title="Introduction to Information Theory">
            
            <img src="http://MeowAlienOwO.github.io/images/49154861.jpg" alt="Introduction to Information Theory">
            
        </a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-14T23:23:43+08:00"><a href="http://MeowAlienOwO.github.io/computer%20science/introduction_to_information_theory/">May 14, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/computer%20science/introduction_to_information_theory/" rel="bookmark" title="Introduction to Information Theory" itemprop="url">Introduction to Information Theory</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>肯德基居然打烊……说好的24小时呢……啊啊……好想给吃撑喂食play……(另外多少弹药可以钓一个打伞的大姐姐……)</p>

<h1 id="简介">简介</h1>

<p>The fundamental problem of communication is that reproducing at one
point either exactly or approximately a message selected at another
point.</p>

<h1 id="信息熵与信息">信息熵与信息</h1>

<h2 id="信息冗余">信息冗余</h2>

<blockquote>
  <p>The quick brown fox jumps over the lazy dog</p>
</blockquote>

<p>这句句子中包含了所有的英文字母。我们可以很明显的看到其中有一些冗余字母，
比如说空格之类。移除所有空格可以使得我们依然能保持原有的意思，
但是移除所有的t,h,e字母则不行。这意味着，我们不能移除所有的冗余。</p>

<h2 id="熵">熵</h2>

<p>我们使用熵(Entropy)来度量某个特殊的随机变量的平均不确定性。</p>

<p>在信息编码方面，熵用于度量描述一个随机变量的平均必须比特数量，
或者被认为是度量信息内容的量。</p>

<p>通常而言，熵可以表示表述一个随机变量所需平均比特数量的下界，
但是在实际的应用中，这往往无法实现。</p>

<p>计算公式：</p>

<p>$H(X) = - \Sigma_x p(x) \log_2 p(x)$</p>

<h2 id="偏离bias">偏离(bias)</h2>

<p>当随机变量存在偏离时，熵的计算公式依然成立。比如在一个有8匹马参加的比赛中，
它们赢的概率分别为1/2, 1/4/, 1/8, 1/16, 1/64， 1/64。
熵值为2，这意味着我们仍然可以用平均长度为2的编码方法来编码所有的信息。</p>

<h2 id="霍夫曼编码">霍夫曼编码</h2>

<h3 id="前缀码prefix-codes">前缀码(prefix codes)</h3>

<p>对于前缀码而言，没有任何元素可以成为另一个元素的开头。这导致了其的唯一性，也就是无歧义性。</p>

<p>霍夫曼编码是前缀码的一种。</p>

<h3 id="创建霍夫曼编码">创建霍夫曼编码</h3>

<p>霍夫曼编码由符号的相对出现频率决定。霍夫曼算法可以保证平均符号长度的最优化。</p>

<blockquote>
  <p>例子：e 0.15, a 0.19, d 0.30, s 0.36</p>
</blockquote>

<p>将所有的未编码符号按照出现频率升序排列：</p>

<blockquote>
  <p>e a d s</p>
</blockquote>

<p>从小到大将两个频率之和相加直到和为1</p>

<blockquote>
  <p>e+a, (e+a)+d, ((e+a)+d)+s</p>
</blockquote>

<p>通过如上求和，构建霍夫曼树(可以看作构建语法树)</p>

<blockquote>
  <pre><code>         1 
         |
      s  +  0.64
              |
           d  +  0.34
                   |
                a  +  e
</code></pre>
</blockquote>

<p>从上到下，左边取0, 右边取1，最终编码为：</p>

<blockquote>
  <p>s 0
d 10
a 110
e 111</p>
</blockquote>
 -->
    
        <p>肯德基居然打烊……说好的24小时呢……啊啊……好想给吃撑喂食play……(另外多少弹药可以钓一个打伞的大姐姐……)</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/computer%20science/physical_layer/" title="Physical Layer">
            
            <img src="http://MeowAlienOwO.github.io/images/49604772.jpg" alt="Physical Layer">
            
        </a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-14T20:15:47+08:00"><a href="http://MeowAlienOwO.github.io/computer%20science/physical_layer/">May 14, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/computer%20science/physical_layer/" rel="bookmark" title="Physical Layer" itemprop="url">Physical Layer</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>第二篇……不要怂就是干…… おかわり！</p>

<h1 id="简介">简介</h1>
<p>物理层定义了电子，时间以及其接口的二进制数据通过信道以信号形式传输的方法。
物理层是网络的基础，其属性，比如流量，延迟与错误率决定了网络的性能。
由于物理极限的存在，网络传输数据的量是有极限的。</p>

<p>两个重要概念：</p>

<ul>
  <li>数字模块化(digital modulation)：模拟信号(analog signals)与数字信号(digital bits)之间是如何
转化的</li>
  <li>多路传输方案(multiplexing schemes)：探索如何将多个会话同时在一个传输中介中传输，同时不互相影响。</li>
</ul>

<h2 id="数据传输的一般过程">数据传输的一般过程</h2>

<ol>
  <li>数据分割，封装成数据包</li>
  <li>数据包转化成二进制流</li>
  <li>二进制流转换成数字信号</li>
  <li>数字信号通过相关元件转化成模拟信号</li>
  <li>模拟信号进入网络传输</li>
</ol>

<h1 id="传输介质">传输介质</h1>

<ul>
  <li>非屏蔽双绞线(Unshielded twisted pair)：最便宜普遍的传输介质，有不同的规格，最多在100米的距离上起作用。
两条铜导线以一定规格相互缠绕，双方的电磁辐射会互相抵消。</li>
  <li>同轴电缆(coaxial cable)：从内到外由铜芯(copper core)，绝缘材料(insulating material)，编织外导电体(braided outer conductor),保护塑料层(protective plastic covering)组成。</li>
  <li>光纤(fiber optics)：应用全反射传输信息的方法。内部由两层玻璃构成，外层是塑料包裹。</li>
</ul>

<h2 id="传输模型">传输模型</h2>

<ul>
  <li>单向传输(simplex transmission)：数据只能向一个方向传输</li>
  <li>半双向传输(half-duplex transmission)：数据在一个确定的时间点上只能向某一方传输，不过可以实现双向的信息传输。</li>
  <li>双向传输(duplex transmission)：数据可以同时双向传输</li>
</ul>

<h2 id="长距离传输">长距离传输</h2>
<p>导线电阻导致信号丢失，从而不能进行长距离传输。
持续的振荡信号往往比其他信号传输的更远。</p>

<h1 id="调制">调制</h1>

<p>调制技术是将数字信号编码为模拟信号的方法。主要有调幅(amplitude modulation,AM)，调频(frequency modulation)，调相(phase modulation)三种方法。
所有这三种方法都需要载波信号(carrier signal)，载波信号使用一个频率来传输数据。</p>

<p>调幅指改变模拟信号的振幅，调频指改变模拟信号的频率，调相(?)指改变模拟信号的相位从而传输信息。</p>

<h2 id="猫modem">猫(MODEM)</h2>

<p>猫，或曰调制解调器，用于调制数字信号为模拟信号，或者将模拟信号解调制为数字信号。双向传输需要两边都有猫。</p>

<h1 id="线路码line-code">线路码(line code)</h1>
<p>线路码（英语：Line code），有时也称传输码。为了便于数字信号传输，将原始的数据码进行一定的修改就得到了线路码。举例来说，当原始数据中存在长时间连续的1或0时，接收方便很难得知每一位信号的时长，也可能误以为信号传输终结而中断通信。线路码还可增加纠错功能，适应信道的特性。常见的线路码包括AMI码、HDB3码等。</p>

<h2 id="时钟恢复与不归零编码">时钟恢复与不归零编码</h2>

<p>时钟恢复通常在不归零编码中使用，不归零编码详见<a href="http://zh.wikipedia.org/wiki/%E4%B8%8D%E6%AD%B8%E9%9B%B6">这里</a>(为何只要一半带宽？)
以下是介绍：</p>

<h3 id="nrz">NRZ</h3>
<p>在电信学中，不归零编码 (non-return-to-zero line code, NRZ) 指的是一种二进制的讯号代码，在这种传输方式中，1 和 0 都分别由不同的电子显著状态来表现，除此之外，没有中性状态、亦没有其他种状态。这种脉冲的能量比归零代码要来得密集，但它传输时是不停歇的，这代表同步信号必须在此代码之外独自传输。</p>

<p>在给定一个信号频率的情况下（比如说位元率），NRZ 代码只需要曼彻斯特代码 (Manchester code) 的一半带宽。</p>

<p>当用于异步传输时，由于缺少中性状态，必须依靠其他种机制，来达成在同步传输中使用时钟侦测错误的资料回复工作。</p>

<p>NRZ-Level 本身并非一种同步系统，而更是一种编码方式，因为它可用于同步环境、或异步环境中，也就是不管有没有明确的时钟讯号，都可以运作。所以，讨论 NRZ-Level 编码是否在时钟“跳动 (clock-edge)”或“跳动之间 (between clock-edge)”并非必要的，因为每一个讯号一定都是以给定的时脉来传输的，这就暗示了讯号内在的时脉。真正的问题是，能否在接收端以当初取样时的同样频率重绘该讯号。</p>

<p>然而，由于 NRZ 讯号的脉冲与时钟是一致的，这就很容易看出 NRZ-Level 和其他编码方式的不同，例如前面提到的曼彻斯特代码，它需要明确的时脉资讯（即 N
RZ 和时钟的 XOR 值），还能看出与 NRZ-Mark 和 NRZ-Inverted 等编码的不同。</p>

<p>NRZ的一个常见编码：1 0 1 0 -&gt; H L H L(1 -&gt; 高电平， 0 -&gt; 低电平)</p>
<h3 id="nrzi">NRZI</h3>
<p>一改变：“1”为物理电平上的改变。“0”为没有改变。</p>

<p>零改变：“0”为物理电平上的改变。“1”为没有改变。</p>

<p>改变发生在当下位元的时钟脉冲前缘。</p>

<p>但是，NRZI 会有长串的 0或1 位元出现，导致时脉回复有困难，可以使用一些编码技巧（例如游长限制）来解决。曼彻斯特代码永远有时脉信号，但传输效率比 NRZI 低。</p>

<p>NRZI 编码被用于磁带的录音、CD的刻录和标准 USB 的传讯。</p>

<p>常见的NRZI编码: 0101 -&gt; H HLLH （高电平为基准，第一个为0表示电平不改变，第二个为1表示改变电平为低，第三个0表示电平不变仍为低，第四个1表示电平改变为高，计算方式为之前电平与当前的XOR）</p>

<h3 id="时钟恢复clock-recovery">时钟恢复(clock recovery)</h3>
<p>我们通常使用接收方与传输方所约定的时钟频率来进行时间同步，从而确定何时对电压进行采样。
简单的来说，所谓时钟恢复就是：根据参考时钟，从数据信号把时钟信号提取出来。相对应的，在信道上只传输串行数据，在信道上并没有时钟信号。数据接收端接收串行数据并进行时钟恢复。–<a href="http://baike.baidu.com/view/3871116.htm">百度百科</a></p>

<h2 id="曼彻斯特编码manchest-encoding">曼彻斯特编码(Manchest Encoding)</h2>

<p>0表示低电平到高电平，1表示高电平到低电平。传输每一个比特简化了时钟恢复，但是同样效率不高–传输数量与传输速度都需要倍增才能达到不归零编码的效果。
好处是可以使用电平的跳变来同步时钟。更多信息见<a href="http://en.wikipedia.org/wiki/Manchester_coed">维基百科</a>，那个例子图很好。</p>

<p>计算曼彻斯特编码时，要使用时钟比特位与编码比特位异或。</p>

<p>曼彻斯特编码的例子：</p>

<p>0101 -&gt; H LH HL LH HL</p>

<p>以太网使用曼彻斯特编码。</p>

<h2 id="波特率baud-rate">波特率(Baud Rate)</h2>

<p>在电子通信领域，波特率（Baud）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。它是对符号传输速率的一种度量，1波特即指每秒传输1个符号，而通过不同的调制方式，可以在一个码元符号上负载多个bit位信息。–<a href="http://zh.wikipedia.org/wiki/%E6%B3%A2%E7%89%B9%E7%8E%87">维基百科</a></p>

<h2 id="帧错误framing-error">帧错误(framing error)</h2>

<p>当收发双方以不同的波特率进行通信时，容易出现帧错误的现象。</p>

<h1 id="数据传输极限">数据传输极限</h1>

<h2 id="nyquist-sampling-theroem">Nyquist Sampling Theroem</h2>

<p>一个无噪声的(noiseless/error-free)的介质的最大传输速率：</p>

<ul>
  <li>$D$：数据比率(bit)每秒，bps</li>
  <li>$B$：带宽(hz)</li>
</ul>

<p>对于使用二进制信号的方案而言，</p>

<p>$Data\ Rate = D = 2B$</p>

<p>对于使用K阶信号的方案而言，</p>

<p>$D = 2B\log_2 K$</p>

<h2 id="shannons-theorem">Shannon’s Theorem</h2>

<p>这个定理针对的是有噪声介质。</p>

<p>信噪比(signal to noise ration)是信号长度与噪声长度之比$S / N$。
信噪比通常用分贝(decibels,db)来表示。$1db = 10 \log_{10} S/N$。</p>

<p>对于有噪声介质的最大数据率为:</p>

<p>$D = B \log_2(1 + S / N)$</p>

 -->
    
        <p>第二篇……不要怂就是干…… おかわり！</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/computer%20science/foundation_of_networking/" title="Foundation of Networking">
            
            <img src="http://MeowAlienOwO.github.io/images/46203097.jpg" alt="Foundation of Networking">
            
        </a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-13T16:59:52+08:00"><a href="http://MeowAlienOwO.github.io/computer%20science/foundation_of_networking/">May 13, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/computer%20science/foundation_of_networking/" rel="bookmark" title="Foundation of Networking" itemprop="url">Foundation of Networking</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>考砸了不开心…………………………………………食我酸素鱼雷啦</p>

<p>这个照旧是网络的笔记……John个大坑比……</p>

<h1 id="网络基础">网络基础</h1>

<h2 id="何为网络network">何为网络(Network)</h2>

<p>网络是在节点之间传输数据的一种结构。</p>

<ul>
  <li>节点是多种多样的</li>
  <li>节点的数量必须多余两个</li>
</ul>

<p>网络由如下设备组成：</p>

<ul>
  <li>计算设备(computing devices)：主机，终端系统。主要用于运行网络应用。</li>
  <li>传输连接(communication links)：光纤，卫星，广播器等。</li>
  <li>分组交换器(packet switches)：用于传输信息，有路由器(router)与交换器
(switch)两种。</li>
</ul>

<p>互联网：网络的网络，由协议与标准来定义信息的传输。</p>

<h2 id="互联网协议protocals">互联网协议(protocals)</h2>

<p>互联网协议控制网络信息的发送与接受。协议定义了网络实体之间的信息传输<em>格式</em>，
<em>顺序</em>与对信息传输的<em>行动</em>。</p>

<h2 id="主机host">主机(host)</h2>

<p>主机以包(packets)的形式传输信息。算法如下：</p>

<ol>
  <li>取得需要传输的信息</li>
  <li>将其截成定长为$L$的小段(chunks)，称之为包(packet)</li>
  <li>将包以某个传输比率(transmission rate)$R$传输至网络</li>
</ol>

<p>传输比率又称连接容量(link capacity)，连接带宽(link bandwidth)，计算公式如下：</p>

<p>$time\ need\ to\ transmit\ L\ bit\ packet\ into\ link = \frac{L(bits)}{R(bits/sec)}$</p>

<h2 id="物理媒体physical-media">物理媒体(Physical Media)</h2>

<p>比特(bit)：在发送者与接收者之间传输</p>

<p>物理链接(physical link)：连接发送者与接收者的物理材料</p>

<p>导向媒体(guided media)：传输信号的固体媒体，比如铜导线，光纤，同轴电缆</p>

<p>无导向媒体(unguided media)：信号可以自由传播。比如广播。</p>

<h2 id="网络核心network-core">网络核心(network core)</h2>

<p>网络核心由一些互相链接的路由器所构成。当主机将应用层的信息转换成包后，将其传输至网络，交给路由器处理，
路由器将收到的包传到下一个路由器。每个包的传输都使用全部的带宽。</p>

<h2 id="网络结构">网络结构</h2>

<p>终端系统通过网络服务提供商(Internet Serveice Providers)连接到网络。所有的ISP必须互相之间链接，
这样才能做到路由器之间的通讯。</p>

<p>我们不能将所有的ISP一一相连，这样我们会有$O(n^2)$的连接数目，难于管理。于是出现了ISP的ISP。
但是，不同的高阶ISP又会带来竞争，为了防止竞争造成无法链接的情况，出现了广域网交换点$Internet Exchange Point, IXP$。
同样的，在连接到高阶ISP之前，ISP们之间先组成各种局域网(Regional Network),再通过这些局域网同广域网相连接。同时，如Google, Microsoft之类的内容提供商可以自己组建自己的网络，
使得他们的服务更加快捷地同终端用户相连接。这些网络被称作内容提供网络(content provider network)。</p>

<p>网络的层级如下：</p>

<ol>
  <li>一级网络服务提供商(Tier 1 ISP)与内容提供网络(Content Provider Network)</li>
  <li>广域网交换点(IXP)</li>
  <li>区域ISP</li>
  <li>入口ISP</li>
</ol>

<h2 id="封包交换分组交换package-switching">封包交换/分组交换(Package switching)</h2>

<p>分组是由一块用户数据和必要的地址和管理信息组成，保证网络能够将数据传递到目标。类似于从邮局发送的包裹上注明的地址一样,只有提供给网络这些信息，网络（邮局）才能把分组（包裹）往正确的地址传送。</p>

<p>分组通过最佳路径(取决于 路由算法)路由到目标。但并不是所有在相同两个主机之间传送的分组（即使是来自同一消息的那些分组）一定要沿着相同的路径传送。</p>

<p>一个数据连接通常传送数据的分组流，它们将不必全部以相同的方式路由过物理网络。目的计算机把收到的所有报文按照适当的顺序重新排列，就能合并恢复出原来的内容。</p>

<p>存储与传输(store-and-forward)：整个包必须在传输到下一个连接之前到达一个路由器。
终端-终端延迟在理想状况下为$2L / R$。</p>

<h3 id="队列与丢包">队列与丢包</h3>

<p>如果路由器的包到达速率超过了其传输速率，那么会发生两种情况：</p>

<ul>
  <li>包被存储在队列中等待，或者</li>
  <li>当队列存储容量满了以后，包会丢失(dropped)</li>
</ul>

<h3 id="两个关键的的网络核心功能">两个关键的的网络核心功能</h3>

<p>路由(routing):决定包的源地址路由器</p>

<p>传输(forwarding):将包从路由的输入转换到正确的输出</p>

<h3 id="另一种核心电路交换circuit-switchingaohu">另一种核心：电路交换(circuit switchingaohu)</h3>

<p>根据
<a href="http://zh.wikipedia.org/wiki/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2" title="电路交换">维基百科</a>的解释，电路交换是在两个通信终端之间建立起一个连接，
双方通过这条通道进行信息的交换。这个连接一直保留到双方的通信结束，在通
信结束之前，连接将始终被占用。这种方式常用在传统的电话网络中。</p>

<h4 id="电路交换的频分多路复用fdm与时分多路复用tdm">电路交换的频分多路复用(FDM)与时分多路复用(TDM)</h4>

<p>频分多路复用(Frequency-division multiplexing)指的是将不同的信息编码至
不同的频率段，从而使得同时可以有多个用户进行通信的技术。频分多路复用在
现代的通信中应用相对较少</p>

<p>时分多路复用(Time-Division Multiplexing)指的是将时间域分成固定的小段，每个小段分配给某个固定的用户
进行通信的技术。典型应用有GSM。</p>

<h3 id="封包交换-vs-电路交换">封包交换 vs 电路交换</h3>

<p>电路交换的最大缺陷是能够服务的用户数量有限，而封包交换往往可以服务更广的用户。</p>

<p>封包交换的优势在于可以共享通信资源以及更加简单(不需要初始化连接)。
但是，封包交换同样存在着延迟与丢包的问题，在需要可信的数据传输的时候，这种方式并不是最好选择。</p>

<h3 id="丢包与延迟的来源">丢包与延迟的来源</h3>

<h4 id="丢包">丢包</h4>

<p>路由器使用队列来储存包的请求，当接受速率大于传输速率时，包会被储存进路由器的队列中。当队列容量满时，这时候便无法接受数据包，造成丢包。</p>

<h4 id="延迟">延迟</h4>

<p>对于单路由节点而言，延迟的来源有四个：</p>

<ul>
  <li>节点处理过程(nodal processing)：包含比特错误校验(check bit errors)，确定输出连接等，通常小于毫秒量级</li>
  <li>队列延迟(queueing delay)：等待输出连接的传输时间，由当前连接的拥挤程度而决定</li>
  <li>转换延迟(transmission delay)：将数据输入传输连接的时间，计算方式为$d_{trans} = L / R$,$L$表示包长度，$R$表示带宽</li>
  <li>传输延迟(propagation delay):数据在连接媒体之间传输的时间，计算方式为$d_{prop} = d / s$，$d$表示物理连接的长度，$s$表示传输速度的中位数</li>
</ul>

<p>计算延迟的公式为：</p>

<p>$d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop}$</p>

<h2 id="层级">层级</h2>

<h3 id="网络协议层级栈">网络协议层级栈</h3>

<ol>
  <li>应用层(application)：支持网络应用，如FTP, SMTP, HTTP等</li>
  <li>传输层(transport)：进程-进程(process-process)之间的数据传输，TCP，UDP</li>
  <li>网络层(network)：路由相关，如IP，路由协议</li>
  <li>连接层(link)：在相邻网络元素之间的数据传输，如以太网(Ethernet),802.111协议，PPP等</li>
  <li>物理层(physical)：二进制数据</li>
</ol>

<h3 id="isoosi七层模型">ISO/OSI七层模型</h3>

<p>在网络协议层级的应用层与传输层之间加入了表示层与会话层。</p>

<ol>
  <li>表示层(presentation)：允许应用解释数据的意义，比如加密，压缩，机器特定的约定，等</li>
  <li>会话层(session)：同步，校验点(checkpoint)，从数据交换中恢复等等</li>
</ol>

<p>一般而言，这两个层级被认为并非绝对必要，且属于应用层的实现。</p>

 -->
    
        <p>考砸了不开心…………………………………………食我酸素鱼雷啦</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->


<div class="pagination">
  
    
      <a href="http://MeowAlienOwO.github.io/page4" class="btn">Previous</a>
    
  
  <ul class="inline-list">
    <li>
      
        <a href="http://MeowAlienOwO.github.io">1</a>
      
    </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io/page2">2</a>
        
      </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io/page3">3</a>
        
      </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io/page4">4</a>
        
      </li>
    
      <li>
        
          <span class="current-page">5</span>
        
      </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io/page6">6</a>
        
      </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io/page7">7</a>
        
      </li>
    
  </ul>
  
    <a href="http://MeowAlienOwO.github.io/page6" class="btn">Next</a>
  
</div><!-- /.pagination -->

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2018 死鱼眼的喵星人. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="http://mademistakes.com/hpstr/" rel="notfollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://MeowAlienOwO.github.io/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://MeowAlienOwO.github.io/assets/js/scripts.min.js"></script>

<script type="text/javascript" src="/assets/js/vendor/share.min.js"></script>




          

</body>
</html>
