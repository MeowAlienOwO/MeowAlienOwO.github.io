<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Entry &#8211; 喵窝[0]号机</title>
<meta name="description" content="一个伪装成技术博客的吐槽网站。">

<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- other plugins config -->
<!-- mathjax -->
<script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$'], [ '\\(', '\\)']]}});
</script>

<!-- Share.js -->
<link href="/assets/css/share.min.css" rel="stylesheet">
<script type="text/javascript" src="/assets/js/vendor/share.min.js"></script>
<!-- end of plugins -->

<meta http-equiv="content-type" content="text/html; charset=utf-8" />


<!-- Open Graph -->
<!-- <meta property="og:locale" content="en_US"> -->
<meta property="og:locale" content="zh_CN" />
<meta property="og:type" content="article">
<meta property="og:title" content="Entry">
<meta property="og:description" content="一个伪装成技术博客的吐槽网站。">
<meta property="og:url" content="http://MeowAlienOwO.github.io/page3/">
<meta property="og:site_name" content="喵窝[0]号机">





<link rel="canonical" href="http://MeowAlienOwO.github.io/page3/">
<link href="http://MeowAlienOwO.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="喵窝[0]号机 Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://MeowAlienOwO.github.io/assets/css/main.css">
<!-- Webfonts -->
<!-- <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css"> -->
<link href="//fonts.useso.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">
<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://MeowAlienOwO.github.io/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://MeowAlienOwO.github.io/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://MeowAlienOwO.github.io/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://MeowAlienOwO.github.io/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://MeowAlienOwO.github.io/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://MeowAlienOwO.github.io/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://MeowAlienOwO.github.io/images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://MeowAlienOwO.github.io/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://MeowAlienOwO.github.io/images/avatar.png" alt="死鱼眼的喵星人 photo" class="author-photo">
					<h4>死鱼眼的喵星人</h4>
					<p>烈風？いいえ、知らない子ですね。（もぐもぐ</p>

				</li>
				<li><a href="http://MeowAlienOwO.github.io/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:meowalienowo@outlook.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				
				
				
				
				<li>
					<a href="http://github.com/https://github.com/MeowAlienOwO"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://MeowAlienOwO.github.io/posts/">All Posts</a></li>
				<li><a href="http://MeowAlienOwO.github.io/tags/">All Tags</a></li>
				
				<li>
				  <a href="/categories/hello/">
				    hello (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/jekyll/">
				    jekyll (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Computer Science/">
				    Computer Science (12)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Math/">
				    Math (2)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Operating System/">
				    Operating System (3)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/ACG/">
				    ACG (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/空之境界/">
				    空之境界 (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/C++/">
				    C++ (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Network/">
				    Network (7)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/自言自语/">
				    自言自语 (2)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/日本語/">
				    日本語 (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/japanese/">
				    japanese (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/11区生活/">
				    11区生活 (2)
				  </a>
				</li>
				
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  <div class="image-credit">Image source: <a href="http://www.pixiv.net/member_illust.php?mode=medium&illust_id=22958285">ZERO | STAR影法師 [pixiv]</a></div><!-- /.image-credit -->
  
    <div class="entry-image">
      <img src="http://MeowAlienOwO.github.io/images/22958285.jpg" alt="Entry">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>喵窝[0]号机</h1>
      <h2>一个伪装成技术博客的吐槽网站。</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/computer%20science/network/link_layer/" title="Link Layer"><img src="http://MeowAlienOwO.github.io/images/50285937.jpg" alt="Link Layer"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-15T01:44:58+08:00"><a href="http://MeowAlienOwO.github.io/computer%20science/network/link_layer/">May 15, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/computer%20science/network/link_layer/" rel="bookmark" title="Link Layer" itemprop="url">Link Layer</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>如你所见，还是复习资料……资源绝赞燃烧中，我要老李……</p>

<h1 id="section">简介与服务</h1>
<p>连接层，又称为数据链路层（Data Link），或称为网络介质层（Network
In-terface），也就是网络的基础建设，广泛应用于通信网的安全技术中，处理
通信与授权控制的核心协议。可在以太网（Ethernet）、光纤（Fiber）、无线
网络（Wireless）、帧传送（Frame Relay）或点对点（PPP）物理网络中为网络
层提供数据传送服务，连接层最重要的任务在于传送及接收物理层所传送的光电
信号。 –度娘</p>

<h2 id="section-1">连接层服务</h2>

<p>连接层包括如下服务：</p>

<h3 id="section-2">帧与链接入口</h3>
<p>数据包被封装成帧。加入了头部(header)跟追踪部(trailer)。同时，如果是共
享介质的话，还有信道入口的信息。MAC地址被用在帧头部来分别源地址与目标
地址。这同IP地址不同。</p>

<h3 id="relable-delivery-between-adjacent-nodes">相邻节点之间的可信传递(relable delivery between adjacent nodes)</h3>
<p>很少用于比特错误很少出现的链接，无线连接拥有更高的错误率。</p>

<h3 id="flow-control">流控制(flow control)</h3>
<p>决定相邻网络节点之间的传输速度</p>

<h3 id="error-detection">错误检测(error detection)</h3>
<p>错误由噪音与信号衰减所带来，接收方发现错误存在后或者请求重新传输，
或者直接丢失帧。</p>

<h3 id="error-correction">错误校正(error correction)</h3>
<p>接收方收到信息并且发现错误后，直接改正错误而不是请求重新传输或者丢包。</p>

<h3 id="section-3">双向传输与半双向传输</h3>
<p>半双向传输只能在某一时间传输一个方向，而双向传输可以同时传输两个方向</p>

<h2 id="section-4">连接层实现相关</h2>
<p>连接层被每个网络主机所实现，在接收机(adaptor)，或者说网路接口卡
(network interface card，NIC，网卡)或者芯片当中实现，比如以太网卡，
802.11卡。以太网芯片集等等。它通过主机系统，将一些硬件，软件与固件组
合起来。</p>

<h3 id="section-5">信息传输流程</h3>

<p>发送者：</p>

<ul>
  <li>将数据封装进帧</li>
  <li>加入错误校验位</li>
</ul>

<p>接收者：</p>

<ul>
  <li>寻找错误并作出处理</li>
  <li>解包，传递给接收的上一层处理</li>
</ul>

<h1 id="section-6">错误检测与校正</h1>

<h2 id="section-7">传输错误</h2>

<p>许多网络复杂度的增加由于接口的敏感性，而这些敏感性可以导致：</p>

<ul>
  <li>传输数据丢失或者改变</li>
  <li>出现随机数据</li>
</ul>

<h2 id="error-detection-1">错误检测(error detection)</h2>

<p>发送者包含一些额外的信息来总结原来的数据信息， 
接收者收到了数据以后检测这些额外的信息。之后，
接收者需要决定接下来是否要进行错误校正或者请求重新传输。</p>

<p>错误校验码：EDC = Error Detection(Correction) Bits</p>

<p>使用错误校验码并不是百分之百可靠的。</p>

<h3 id="parity-checking">奇偶校验位(parity checking)</h3>

<p>计算数据中1的数量，然后加入一个额外的比特位奇偶校验来进行奇偶校验。</p>

<p>该方法简单，但是只能检测很少的一部分错误。我们使用校验和(checksum)与循
环冗余校验码(cyclic redundancy checks)来进行检测。</p>

<h3 id="checksum">校验和(checksum)</h3>

<p>将数据分成若干个段，视之为整数，进行加和，储存结果。通常会使用16位与32
位校验和，而且通常对整个包进行校验和计算。</p>

<p>校验和通常会为数据增加16或者32位，而计算负荷只是简单的加法操作。相对的，
校验和有可能会存在一些未发现的错误。</p>

<h3 id="cyclic-redundancy-check">循环冗余检测(cyclic redundancy check)</h3>
<p>循环冗余检测比校验和更加强大，可以检测更多的错误，它是基于二进制除法的。</p>

<p>发送方希望发送$D$,一个长度为$d$的数据，发送与接收双方约定一个生成器
$G$,其长度为$r + 1$。</p>

<p>发送者在原有数据后加入一个$R$，使得$DR$恰好在二进制除法下被$G$所整除。
接收者进行反向操作并且检查余数是否为0。</p>

<h1 id="multiple-access-protocols">多址接入协议(Multiple Access Protocols)</h1>

<p>解决问题：</p>

<ul>
  <li>单个共享的广播信道</li>
  <li>两个或更多的节点同时进行传输活动，可能导致碰撞(collision)发生</li>
</ul>

<p>多址接入协议使用分布式算法来决定节点如何共享信道。</p>

<h2 id="section-8">一个理想的协议</h2>

<p>假设广播信道以$R$比特率进行传输。</p>

<p>理想方案是当一个节点希望传输时，它可以以$R$比特率传输。
当$M$个节点希望传输时，每个节点可以以平均$R/M$的比特率传输。
同时完全的去中心化：没有节点用来组织传输，不需要进行时钟同步/时间段同步等。</p>

<h2 id="mac">MAC协议</h2>

<h3 id="channel-partitioning">信道分配(channel partitioning)</h3>

<p>将信道分解为小的”碎片”(pieces)，比如时间段，频率，编码等等，将每个碎片
互斥地分配给节点。前述的FDM与TDM方法就属于这一种。</p>

<h3 id="random-access">随机接入(random access)</h3>

<p>不分解信道，允许碰撞发生，发生后从碰撞中恢复。</p>

<h3 id="taking-turns">轮流(“taking turns”)</h3>

<p>轮流方法指的是节点轮流占用信道，但是节点需要传输较长的信息可以使用更长
的时间。从中心站点得到权限，包括令牌(token)传输。</p>

<p>典型例子如蓝牙，FDDI，令牌环(token ring)等。</p>

<h2 id="csmacarrier-sence-multiple-access">载波侦听多路访问：CSMA(carrier sence multiple access)</h2>

<p>CSMA在传播之前监听：</p>

<ul>
  <li>如果信道空闲，则将整一帧传输；</li>
  <li>如果信道忙碌，则推迟传输。</li>
</ul>

<p>来自百度百科：
采用分布式控制方法，附接总线的各个结点通过竞争的方式，获得总线的使用权。
只有获得使用权的结点才可以向总线发送信息帧，该信息帧将被附接总线的所有结点感知。包括以下三个要点：载波侦听——发送结点在发送信息帧之前，必须侦听媒体是否处于空闲状态；多路访问——具有两种含义，既表示多个结点可以同时访问媒体，也表示一个结点发送的信息帧可以被多个结点所接收；冲突检测——发送结点在发出信息帧的同时，还必须监听媒体，判断是否发生冲突（同一时刻，有无其他结点也在发送信息帧）。IEEE 802.3或者OSI 8802/3定义了CSMA/CD的标准。</p>

<p>关于冲突检测：</p>

<p>b其概念时间模型分为三个时期：传输周期，竞争周期和空闲周期.
值得一提的是，监听的机制：传输数据时，他的硬件进行监听电缆，如果读回来的信息与发送的不一致，便知发送冲突了.这里，当然需要一种特殊的信号编码方案，能够检测出两个OV信号冲突.（或者在此冲突下，故意不检测，因信号没有损坏）
有线网中，冲突检测的最核心内容是 帧碎片（即检测到网络中有小于这个大小的帧就认为是帧碎片，因为传输2端都在传输造成冲突，2端数据在网络中都只有1部分，即不完整，产生碎片）。
在无线网中由于有隐藏结点（即每个结点不知道也不可能知道整个网络的实时情况），因此无法“检测”所以CSMA/CA（CSMA with Collision Avoidance）载波侦听多路访问冲突避免 就应运而生了，它是利用RTS/CTS（即类似TCP的握手协议)的应答策略来保证在传输中结点不会再接受请求，从而解决了无线网中的冲突。
总之：先听后发，边听边发，冲突不发，稍后再发</p>

<h3 id="csmacdcollision-detection">CSMA/CD(collision detection)</h3>

<p>CSMA依然会导致碰撞的发生：两个节点无法互相了解彼此的传输状态。</p>

<p>CSMA/CD用于有线传输。它可以在短时间内发现碰撞的产生并且阻止其传输，减
少了信道的浪费。</p>

<p>以太网的CSMA/CD算法：</p>

<ol>
  <li>网卡从网络层收到数据包，创建帧</li>
  <li>如果网卡检测到信道空闲，开始传输帧；如果检测到信道忙碌，等待直到信道空闲。</li>
  <li>如果网卡传输完毕整个帧而没有检测到碰撞，则传输完毕</li>
  <li>如果网卡检测到有碰撞发生，则停止传输并且发送阻塞信号(jam signal)</li>
  <li>当停止传输时，网卡使用二进制指数补偿方法:在第$m$个碰撞发生时，随机从
${2..2^m - 1}$中选取一个$k$，等待$K * 512$个比特时间，返回第二步。
显然的，碰撞越多，等待时间越长。</li>
</ol>

<h3 id="csmacacollision-avoidance">CSMA/CA(collision avoidance)</h3>

<h4 id="section-9">隐藏节点问题</h4>

<p>假设节点A,B,C，A与C只能向B进行信号传输。这意味着A与C不知道彼此之间的信
息。当A向B发送信息时，C的侦测认为BC是空闲的，于是C也发送信息。这时，碰
撞会在B节点发生，而A与C的碰撞检测全部失效。我们说这种情况下，A对C隐藏
(A is hidden for C)。</p>

<p>隐藏节点问题往往在无线网络通信中发生，需要在接收方进行载波检测。</p>

<p>“虚拟载波感应”(virtual carrier sensing)：发送者询问接收者是否能”听到”
别的节点发来的信息，如果是，则认为信道忙碌。</p>

<h4 id="csmaca">无线局域网与CSMA/CA</h4>

<p>由于无线网络的开放性，碰撞检测在这种环境下很容易失效。我们使用碰撞避免
方法来处理这种情况。发送方向接收方发送一个小型的请求信息，接收方向所有
的相邻节点返回一个”clear to send”信息。</p>

<h1 id="local-area-network-lan">局域网(Local Area Network, LAN)</h1>

<p>局域网（Local Area Network，LAN）是在一个局部的地理范围内（如一个学校、
工厂和机关内），一般是方圆几千米以内，将各种计算机，外部设备和数据库等
互相联接起来组成的计算机通信网。 – 百度百科</p>

<h2 id="section-10">寻址</h2>

<h3 id="mac-1">MAC地址</h3>

<p>在局域网中使用，用于从物理上相互连接的接口得到帧。通常而言，MAC地址为
48位，被烧录在NIC的ROM中，有的时候可以被软件所设置。</p>

<p>MAC地址被IEEE所管理，制造商购买一个特定的地址空间来保证元件的独特性。</p>

<p>同IP地址的关系：</p>

<p>MAC有独特性，而IP地址则是区域共享的。</p>

<h2 id="ethernet">以太网(Ethernet)</h2>

<p>以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网络使用CSMA/CD（载波监听多路访问及冲突检测）技术，并以10M/S的速率运行在多种类型的电缆上。以太网与IEEE802.3系列标准相类似。</p>

<p>以太网协议在网卡之间没有握手行为，所以是无连接(connectionless)的；接收方不返回”acks”/”nacks”给发送网卡，所以是不可靠(unreliable)的。丢失帧中的数据只在更高层级中规定了才恢复，否则数据就直接丢失。</p>

<p>以太网的MAC协议：无追踪的CSMA/CD，使用二进制补偿方法。</p>

<h3 id="section-11">物理拓扑</h3>

<p>总线型bus:在90年代中期比较流行，所有的节点在一个碰撞域之中(可以互相碰撞)。</p>

<p>星型star:现在比较常用，在中心有一个转换节点，每一个”辐条”(spoke)上运行一个独立的以太网协议，互相之间不发生碰撞。</p>

<h2 id="section-12">扩展</h2>
<p>### LAN的距离极限</p>

<p>MAC协议，比如CSMA/CD需要与导线长度成比例的时间;同时信号强度也会随着距离而衰减。</p>

<p>另外，网络设计者需要在一定的成本之下，考虑容量，延迟与距离的取舍。</p>

<h3 id="section-13">光纤的光学扩展</h3>

<p>光纤调制解调器可以在计算机与收发机之间扩展链接。</p>

<blockquote>
  <pre><code>                           收发机-&gt;Ethernet
                            ^  计算机-&gt;MODEM------------------MODEM
</code></pre>
</blockquote>

<h3 id="repeater">中继器(repeater)</h3>

<p>中继器将以太网段(segments)连接起来，它只放大信号强度，不关心帧信息。
中继器只处理信号强度，不处理延迟。光纤调制解调器可以在中继器与长距离扩展之间使用。</p>

<p>中继器的最大问题是，它会将错误与碰撞信号一起增强传输。</p>

<p>以太网标准规定在两个计算机之间不应有多于4个的中继器。</p>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>—R1—segment1,floor1—R4—segment2,floor1—</td>
      </tr>
      <tr>
        <td> </td>
      </tr>
      <tr>
        <td>—R2—segment1,floor2—R5—segment2,floor2—</td>
      </tr>
      <tr>
        <td> </td>
      </tr>
      <tr>
        <td>—R3—segment1,floor3—R6—segment2,floor3—</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h3 id="bridges">桥(bridges)</h3>

<p>桥可以将两个段之间连接起来，但是在帧层次使用。
使用混杂模式(promiscuous，真是个好词……)并且传送所有的帧。但是，错误帧，比如噪音与碰撞，例外。</p>

<p>一个例子：</p>

<blockquote>
  <p>——segment 1——Bridge——segment 2——
u v w                                    x y z</p>
</blockquote>

<table summary="段的例子">
<tr>
<th>事件</th>
<th>段1列表</th>
<th>段2列表</th>
</tr>

<tr>
<td>桥引导</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>u to v</td>
<td>u</td>
<td>-</td>
</tr>


<tr>
<td>v to u</td>
<td>u,v</td>
<td>-</td>
</tr>


<tr>
<td>z广播</td>
<td>u,v</td>
<td>z</td>
</tr>


<tr>
<td>y to v</td>
<td>u,v</td>
<td>z,y</td>
</tr>


<tr>
<td>y to x</td>
<td>u,b</td>
<td>z,y</td>
</tr>


<tr>
<td>x to w</td>
<td>u,v</td>
<td>z,y,x</td>
</tr>


<tr>
<td>w to z</td>
<td>u,v,w</td>
<td>z,y,x</td>
</tr>


</table>

<h4 id="frame-filtering">帧过滤(frame filtering)</h4>

<p>只有在需要传送帧的时候才是必要的。</p>

<ul>
  <li>目标是另一个段(segment)</li>
  <li>使用广播地址</li>
</ul>

<p>桥知道计算机在哪一段，并且知道帧发送的时间。</p>

<p>当帧到达桥时，解压缩源地址，更新信息，并且检查目标地址用于传输。</p>

<h3 id="switching">转换器(switching)</h3>

<p>一个简单的在计算机之间传送帧的电子设备。</p>

<p>鉴于集线器(hub)模拟了共享介质，转换器模拟了每个计算机一段的桥接的局域网。</p>

<p>好处在于由于平行，可以传送更大的数据量。有些情况下，使用集线器跟转换器来减少成本。</p>

 -->
    
        <p>如你所见，还是复习资料……资源绝赞燃烧中，我要老李……</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/computer%20science/network/introduction_to_information_theory/" title="Introduction to Information Theory"><img src="http://MeowAlienOwO.github.io/images/49154861.jpg" alt="Introduction to Information Theory"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-14T23:23:43+08:00"><a href="http://MeowAlienOwO.github.io/computer%20science/network/introduction_to_information_theory/">May 14, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/computer%20science/network/introduction_to_information_theory/" rel="bookmark" title="Introduction to Information Theory" itemprop="url">Introduction to Information Theory</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>肯德基居然打烊……说好的24小时呢……啊啊……好想给吃撑喂食play……(另外多少弹药可以钓一个打伞的大姐姐……)</p>

<h1 id="section">简介</h1>

<p>The fundamental problem of communication is that reproducing at one
point either exactly or approximately a message selected at another
point.</p>

<h1 id="section-1">信息熵与信息</h1>

<h2 id="section-2">信息冗余</h2>

<blockquote>
  <p>The quick brown fox jumps over the lazy dog</p>
</blockquote>

<p>这句句子中包含了所有的英文字母。我们可以很明显的看到其中有一些冗余字母，
比如说空格之类。移除所有空格可以使得我们依然能保持原有的意思，
但是移除所有的t,h,e字母则不行。这意味着，我们不能移除所有的冗余。</p>

<h2 id="section-3">熵</h2>

<p>我们使用熵(Entropy)来度量某个特殊的随机变量的平均不确定性。</p>

<p>在信息编码方面，熵用于度量描述一个随机变量的平均必须比特数量，
或者被认为是度量信息内容的量。</p>

<p>通常而言，熵可以表示表述一个随机变量所需平均比特数量的下界，
但是在实际的应用中，这往往无法实现。</p>

<p>计算公式：</p>

<p>$H(X) = - \Sigma_x p(x) \log_2 p(x)$</p>

<h2 id="bias">偏离(bias)</h2>

<p>当随机变量存在偏离时，熵的计算公式依然成立。比如在一个有8匹马参加的比赛中，
它们赢的概率分别为1/2, 1/4/, 1/8, 1/16, 1/64， 1/64。
熵值为2，这意味着我们仍然可以用平均长度为2的编码方法来编码所有的信息。</p>

<h2 id="section-4">霍夫曼编码</h2>

<h3 id="prefix-codes">前缀码(prefix codes)</h3>

<p>对于前缀码而言，没有任何元素可以成为另一个元素的开头。这导致了其的唯一性，也就是无歧义性。</p>

<p>霍夫曼编码是前缀码的一种。</p>

<h3 id="section-5">创建霍夫曼编码</h3>

<p>霍夫曼编码由符号的相对出现频率决定。霍夫曼算法可以保证平均符号长度的最优化。</p>

<blockquote>
  <p>例子：e 0.15, a 0.19, d 0.30, s 0.36</p>
</blockquote>

<p>将所有的未编码符号按照出现频率升序排列：</p>

<blockquote>
  <p>e a d s</p>
</blockquote>

<p>从小到大将两个频率之和相加直到和为1</p>

<blockquote>
  <p>e+a, (e+a)+d, ((e+a)+d)+s</p>
</blockquote>

<p>通过如上求和，构建霍夫曼树(可以看作构建语法树)</p>

<blockquote>
  <pre><code>         1 
         |
      s  +  0.64
              |
           d  +  0.34
                   |
                a  +  e
</code></pre>
</blockquote>

<p>从上到下，左边取0, 右边取1，最终编码为：</p>

<blockquote>
  <p>s 0
d 10
a 110
e 111</p>
</blockquote>
 -->
    
        <p>肯德基居然打烊……说好的24小时呢……啊啊……好想给吃撑喂食play……(另外多少弹药可以钓一个打伞的大姐姐……)</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/computer%20science/network/physical_layer/" title="Physical Layer"><img src="http://MeowAlienOwO.github.io/images/49604772.jpg" alt="Physical Layer"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-14T20:15:47+08:00"><a href="http://MeowAlienOwO.github.io/computer%20science/network/physical_layer/">May 14, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/computer%20science/network/physical_layer/" rel="bookmark" title="Physical Layer" itemprop="url">Physical Layer</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>第二篇……不要怂就是干…… おかわり！</p>

<h1 id="section">简介</h1>
<p>物理层定义了电子，时间以及其接口的二进制数据通过信道以信号形式传输的方法。
物理层是网络的基础，其属性，比如流量，延迟与错误率决定了网络的性能。
由于物理极限的存在，网络传输数据的量是有极限的。</p>

<p>两个重要概念：</p>

<ul>
  <li>数字模块化(digital modulation)：模拟信号(analog signals)与数字信号(digital bits)之间是如何
转化的</li>
  <li>多路传输方案(multiplexing schemes)：探索如何将多个会话同时在一个传输中介中传输，同时不互相影响。</li>
</ul>

<h2 id="section-1">数据传输的一般过程</h2>

<ol>
  <li>数据分割，封装成数据包</li>
  <li>数据包转化成二进制流</li>
  <li>二进制流转换成数字信号</li>
  <li>数字信号通过相关元件转化成模拟信号</li>
  <li>模拟信号进入网络传输</li>
</ol>

<h1 id="section-2">传输介质</h1>

<ul>
  <li>非屏蔽双绞线(Unshielded twisted pair)：最便宜普遍的传输介质，有不同的规格，最多在100米的距离上起作用。
两条铜导线以一定规格相互缠绕，双方的电磁辐射会互相抵消。</li>
  <li>同轴电缆(coaxial cable)：从内到外由铜芯(copper core)，绝缘材料(insulating material)，编织外导电体(braided outer conductor),保护塑料层(protective plastic covering)组成。</li>
  <li>光纤(fiber optics)：应用全反射传输信息的方法。内部由两层玻璃构成，外层是塑料包裹。</li>
</ul>

<h2 id="section-3">传输模型</h2>

<ul>
  <li>单向传输(simplex transmission)：数据只能向一个方向传输</li>
  <li>半双向传输(half-duplex transmission)：数据在一个确定的时间点上只能向某一方传输，不过可以实现双向的信息传输。</li>
  <li>双向传输(duplex transmission)：数据可以同时双向传输</li>
</ul>

<h2 id="section-4">长距离传输</h2>
<p>导线电阻导致信号丢失，从而不能进行长距离传输。
持续的振荡信号往往比其他信号传输的更远。</p>

<h1 id="section-5">调制</h1>

<p>调制技术是将数字信号编码为模拟信号的方法。主要有调幅(amplitude modulation,AM)，调频(frequency modulation)，调相(phase modulation)三种方法。
所有这三种方法都需要载波信号(carrier signal)，载波信号使用一个频率来传输数据。</p>

<p>调幅指改变模拟信号的振幅，调频指改变模拟信号的频率，调相(?)指改变模拟信号的相位从而传输信息。</p>

<h2 id="modem">猫(MODEM)</h2>

<p>猫，或曰调制解调器，用于调制数字信号为模拟信号，或者将模拟信号解调制为数字信号。双向传输需要两边都有猫。</p>

<h1 id="line-code">线路码(line code)</h1>
<p>线路码（英语：Line code），有时也称传输码。为了便于数字信号传输，将原始的数据码进行一定的修改就得到了线路码。举例来说，当原始数据中存在长时间连续的1或0时，接收方便很难得知每一位信号的时长，也可能误以为信号传输终结而中断通信。线路码还可增加纠错功能，适应信道的特性。常见的线路码包括AMI码、HDB3码等。</p>

<h2 id="section-6">时钟恢复与不归零编码</h2>

<p>时钟恢复通常在不归零编码中使用，不归零编码详见<a href="http://zh.wikipedia.org/wiki/%E4%B8%8D%E6%AD%B8%E9%9B%B6">这里</a>(为何只要一半带宽？)
以下是介绍：</p>

<h3 id="nrz">NRZ</h3>
<p>在电信学中，不归零编码 (non-return-to-zero line code, NRZ) 指的是一种二进制的讯号代码，在这种传输方式中，1 和 0 都分别由不同的电子显著状态来表现，除此之外，没有中性状态、亦没有其他种状态。这种脉冲的能量比归零代码要来得密集，但它传输时是不停歇的，这代表同步信号必须在此代码之外独自传输。</p>

<p>在给定一个信号频率的情况下（比如说位元率），NRZ 代码只需要曼彻斯特代码 (Manchester code) 的一半带宽。</p>

<p>当用于异步传输时，由于缺少中性状态，必须依靠其他种机制，来达成在同步传输中使用时钟侦测错误的资料回复工作。</p>

<p>NRZ-Level 本身并非一种同步系统，而更是一种编码方式，因为它可用于同步环境、或异步环境中，也就是不管有没有明确的时钟讯号，都可以运作。所以，讨论 NRZ-Level 编码是否在时钟“跳动 (clock-edge)”或“跳动之间 (between clock-edge)”并非必要的，因为每一个讯号一定都是以给定的时脉来传输的，这就暗示了讯号内在的时脉。真正的问题是，能否在接收端以当初取样时的同样频率重绘该讯号。</p>

<p>然而，由于 NRZ 讯号的脉冲与时钟是一致的，这就很容易看出 NRZ-Level 和其他编码方式的不同，例如前面提到的曼彻斯特代码，它需要明确的时脉资讯（即 N
RZ 和时钟的 XOR 值），还能看出与 NRZ-Mark 和 NRZ-Inverted 等编码的不同。</p>

<p>NRZ的一个常见编码：1 0 1 0 -&gt; H L H L(1 -&gt; 高电平， 0 -&gt; 低电平)
### NRZI
一改变：“1”为物理电平上的改变。“0”为没有改变。</p>

<p>零改变：“0”为物理电平上的改变。“1”为没有改变。</p>

<p>改变发生在当下位元的时钟脉冲前缘。</p>

<p>但是，NRZI 会有长串的 0或1 位元出现，导致时脉回复有困难，可以使用一些编码技巧（例如游长限制）来解决。曼彻斯特代码永远有时脉信号，但传输效率比 NRZI 低。</p>

<p>NRZI 编码被用于磁带的录音、CD的刻录和标准 USB 的传讯。</p>

<p>常见的NRZI编码: 0101 -&gt; H HLLH （高电平为基准，第一个为0表示电平不改变，第二个为1表示改变电平为低，第三个0表示电平不变仍为低，第四个1表示电平改变为高，计算方式为之前电平与当前的XOR）</p>

<h3 id="clock-recovery">时钟恢复(clock recovery)</h3>
<p>我们通常使用接收方与传输方所约定的时钟频率来进行时间同步，从而确定何时对电压进行采样。
简单的来说，所谓时钟恢复就是：根据参考时钟，从数据信号把时钟信号提取出来。相对应的，在信道上只传输串行数据，在信道上并没有时钟信号。数据接收端接收串行数据并进行时钟恢复。–<a href="http://baike.baidu.com/view/3871116.htm">百度百科</a></p>

<h2 id="manchest-encoding">曼彻斯特编码(Manchest Encoding)</h2>

<p>0表示低电平到高电平，1表示高电平到低电平。传输每一个比特简化了时钟恢复，但是同样效率不高–传输数量与传输速度都需要倍增才能达到不归零编码的效果。
好处是可以使用电平的跳变来同步时钟。更多信息见<a href="http://en.wikipedia.org/wiki/Manchester_coed">维基百科</a>，那个例子图很好。</p>

<p>计算曼彻斯特编码时，要使用时钟比特位与编码比特位异或。</p>

<p>曼彻斯特编码的例子：</p>

<p>0101 -&gt; H LH HL LH HL</p>

<p>以太网使用曼彻斯特编码。</p>

<h2 id="baud-rate">波特率(Baud Rate)</h2>

<p>在电子通信领域，波特率（Baud）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。它是对符号传输速率的一种度量，1波特即指每秒传输1个符号，而通过不同的调制方式，可以在一个码元符号上负载多个bit位信息。–<a href="http://zh.wikipedia.org/wiki/%E6%B3%A2%E7%89%B9%E7%8E%87">维基百科</a></p>

<h2 id="framing-error">帧错误(framing error)</h2>

<p>当收发双方以不同的波特率进行通信时，容易出现帧错误的现象。</p>

<h1 id="section-7">数据传输极限</h1>

<h2 id="nyquist-sampling-theroem">Nyquist Sampling Theroem</h2>

<p>一个无噪声的(noiseless/error-free)的介质的最大传输速率：</p>

<ul>
  <li>$D$：数据比率(bit)每秒，bps</li>
  <li>$B$：带宽(hz)</li>
</ul>

<p>对于使用二进制信号的方案而言，</p>

<p>$Data\ Rate = D = 2B$</p>

<p>对于使用K阶信号的方案而言，</p>

<p>$D = 2B\log_2 K$</p>

<h2 id="shannons-theorem">Shannon’s Theorem</h2>

<p>这个定理针对的是有噪声介质。</p>

<p>信噪比(signal to noise ration)是信号长度与噪声长度之比$S / N$。
信噪比通常用分贝(decibels,db)来表示。$1db = 10 \log_{10} S/N$。</p>

<p>对于有噪声介质的最大数据率为:</p>

<p>$D = B \log_2(1 + S / N)$</p>

 -->
    
        <p>第二篇……不要怂就是干…… おかわり！</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/computer%20science/network/foundation_of_networking/" title="Foundation of Networking"><img src="http://MeowAlienOwO.github.io/images/46203097.jpg" alt="Foundation of Networking"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-13T16:59:52+08:00"><a href="http://MeowAlienOwO.github.io/computer%20science/network/foundation_of_networking/">May 13, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/computer%20science/network/foundation_of_networking/" rel="bookmark" title="Foundation of Networking" itemprop="url">Foundation of Networking</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>考砸了不开心…………………………………………食我酸素鱼雷啦</p>

<p>这个照旧是网络的笔记……John个大坑比……</p>

<h1 id="section">网络基础</h1>

<h2 id="network">何为网络(Network)</h2>

<p>网络是在节点之间传输数据的一种结构。</p>

<ul>
  <li>节点是多种多样的</li>
  <li>节点的数量必须多余两个</li>
</ul>

<p>网络由如下设备组成：</p>

<ul>
  <li>计算设备(computing devices)：主机，终端系统。主要用于运行网络应用。</li>
  <li>传输连接(communication links)：光纤，卫星，广播器等。</li>
  <li>分组交换器(packet switches)：用于传输信息，有路由器(router)与交换器
(switch)两种。</li>
</ul>

<p>互联网：网络的网络，由协议与标准来定义信息的传输。</p>

<h2 id="protocals">互联网协议(protocals)</h2>

<p>互联网协议控制网络信息的发送与接受。协议定义了网络实体之间的信息传输<em>格式</em>，
<em>顺序</em>与对信息传输的<em>行动</em>。</p>

<h2 id="host">主机(host)</h2>

<p>主机以包(packets)的形式传输信息。算法如下：</p>

<ol>
  <li>取得需要传输的信息</li>
  <li>将其截成定长为$L$的小段(chunks)，称之为包(packet)</li>
  <li>将包以某个传输比率(transmission rate)$R$传输至网络</li>
</ol>

<p>传输比率又称连接容量(link capacity)，连接带宽(link bandwidth)，计算公式如下：</p>

<p>$time\ need\ to\ transmit\ L\ bit\ packet\ into\ link = \frac{L(bits)}{R(bits/sec)}$</p>

<h2 id="physical-media">物理媒体(Physical Media)</h2>

<p>比特(bit)：在发送者与接收者之间传输</p>

<p>物理链接(physical link)：连接发送者与接收者的物理材料</p>

<p>导向媒体(guided media)：传输信号的固体媒体，比如铜导线，光纤，同轴电缆</p>

<p>无导向媒体(unguided media)：信号可以自由传播。比如广播。</p>

<h2 id="network-core">网络核心(network core)</h2>

<p>网络核心由一些互相链接的路由器所构成。当主机将应用层的信息转换成包后，将其传输至网络，交给路由器处理，
路由器将收到的包传到下一个路由器。每个包的传输都使用全部的带宽。</p>

<h2 id="section-1">网络结构</h2>

<p>终端系统通过网络服务提供商(Internet Serveice Providers)连接到网络。所有的ISP必须互相之间链接，
这样才能做到路由器之间的通讯。</p>

<p>我们不能将所有的ISP一一相连，这样我们会有$O(n^2)$的连接数目，难于管理。于是出现了ISP的ISP。
但是，不同的高阶ISP又会带来竞争，为了防止竞争造成无法链接的情况，出现了广域网交换点$Internet Exchange Point, IXP$。
同样的，在连接到高阶ISP之前，ISP们之间先组成各种局域网(Regional Network),再通过这些局域网同广域网相连接。同时，如Google, Microsoft之类的内容提供商可以自己组建自己的网络，
使得他们的服务更加快捷地同终端用户相连接。这些网络被称作内容提供网络(content provider network)。</p>

<p>网络的层级如下：</p>

<ol>
  <li>一级网络服务提供商(Tier 1 ISP)与内容提供网络(Content Provider Network)</li>
  <li>广域网交换点(IXP)</li>
  <li>区域ISP</li>
  <li>入口ISP</li>
</ol>

<h2 id="package-switching">封包交换/分组交换(Package switching)</h2>

<p>分组是由一块用户数据和必要的地址和管理信息组成，保证网络能够将数据传递到目标。类似于从邮局发送的包裹上注明的地址一样,只有提供给网络这些信息，网络（邮局）才能把分组（包裹）往正确的地址传送。</p>

<p>分组通过最佳路径(取决于 路由算法)路由到目标。但并不是所有在相同两个主机之间传送的分组（即使是来自同一消息的那些分组）一定要沿着相同的路径传送。</p>

<p>一个数据连接通常传送数据的分组流，它们将不必全部以相同的方式路由过物理网络。目的计算机把收到的所有报文按照适当的顺序重新排列，就能合并恢复出原来的内容。</p>

<p>存储与传输(store-and-forward)：整个包必须在传输到下一个连接之前到达一个路由器。
终端-终端延迟在理想状况下为$2L / R$。</p>

<h3 id="section-2">队列与丢包</h3>

<p>如果路由器的包到达速率超过了其传输速率，那么会发生两种情况：</p>

<ul>
  <li>包被存储在队列中等待，或者</li>
  <li>当队列存储容量满了以后，包会丢失(dropped)</li>
</ul>

<h3 id="section-3">两个关键的的网络核心功能</h3>

<p>路由(routing):决定包的源地址路由器</p>

<p>传输(forwarding):将包从路由的输入转换到正确的输出</p>

<h3 id="circuit-switchingaohu">另一种核心：电路交换(circuit switchingaohu)</h3>

<p>根据
<a href="http://zh.wikipedia.org/wiki/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2" title="电路交换">维基百科</a>的解释，电路交换是在两个通信终端之间建立起一个连接，
双方通过这条通道进行信息的交换。这个连接一直保留到双方的通信结束，在通
信结束之前，连接将始终被占用。这种方式常用在传统的电话网络中。</p>

<h4 id="fdmtdm">电路交换的频分多路复用(FDM)与时分多路复用(TDM)</h4>

<p>频分多路复用(Frequency-division multiplexing)指的是将不同的信息编码至
不同的频率段，从而使得同时可以有多个用户进行通信的技术。频分多路复用在
现代的通信中应用相对较少</p>

<p>时分多路复用(Time-Division Multiplexing)指的是将时间域分成固定的小段，每个小段分配给某个固定的用户
进行通信的技术。典型应用有GSM。</p>

<h3 id="vs-">封包交换 vs 电路交换</h3>

<p>电路交换的最大缺陷是能够服务的用户数量有限，而封包交换往往可以服务更广的用户。</p>

<p>封包交换的优势在于可以共享通信资源以及更加简单(不需要初始化连接)。
但是，封包交换同样存在着延迟与丢包的问题，在需要可信的数据传输的时候，这种方式并不是最好选择。</p>

<h3 id="section-4">丢包与延迟的来源</h3>

<h4 id="section-5">丢包</h4>

<p>路由器使用队列来储存包的请求，当接受速率大于传输速率时，包会被储存进路由器的队列中。当队列容量满时，这时候便无法接受数据包，造成丢包。</p>

<h4 id="section-6">延迟</h4>

<p>对于单路由节点而言，延迟的来源有四个：</p>

<ul>
  <li>节点处理过程(nodal processing)：包含比特错误校验(check bit errors)，确定输出连接等，通常小于毫秒量级</li>
  <li>队列延迟(queueing delay)：等待输出连接的传输时间，由当前连接的拥挤程度而决定</li>
  <li>转换延迟(transmission delay)：将数据输入传输连接的时间，计算方式为$d_{trans} = L / R$,$L$表示包长度，$R$表示带宽</li>
  <li>传输延迟(propagation delay):数据在连接媒体之间传输的时间，计算方式为$d_{prop} = d / s$，$d$表示物理连接的长度，$s$表示传输速度的中位数</li>
</ul>

<p>计算延迟的公式为：</p>

<p>$d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop}$</p>

<h2 id="section-7">层级</h2>

<h3 id="section-8">网络协议层级栈</h3>

<ol>
  <li>应用层(application)：支持网络应用，如FTP, SMTP, HTTP等</li>
  <li>传输层(transport)：进程-进程(process-process)之间的数据传输，TCP，UDP</li>
  <li>网络层(network)：路由相关，如IP，路由协议</li>
  <li>连接层(link)：在相邻网络元素之间的数据传输，如以太网(Ethernet),802.111协议，PPP等</li>
  <li>物理层(physical)：二进制数据</li>
</ol>

<h3 id="isoosi">ISO/OSI七层模型</h3>

<p>在网络协议层级的应用层与传输层之间加入了表示层与会话层。</p>

<ol>
  <li>表示层(presentation)：允许应用解释数据的意义，比如加密，压缩，机器特定的约定，等</li>
  <li>会话层(session)：同步，校验点(checkpoint)，从数据交换中恢复等等</li>
</ol>

<p>一般而言，这两个层级被认为并非绝对必要，且属于应用层的实现。</p>

 -->
    
        <p>考砸了不开心…………………………………………食我酸素鱼雷啦</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/computer%20science/math/machine_and_their_language(2)/" title="MAL-下推自动机与上下文无关语言"><img src="http://MeowAlienOwO.github.io/images/31958311.png" alt="MAL-下推自动机与上下文无关语言"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-03T14:49:02+08:00"><a href="http://MeowAlienOwO.github.io/computer%20science/math/machine_and_their_language(2)/">May 03, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/computer%20science/math/machine_and_their_language(2)/" rel="bookmark" title="MAL-下推自动机与上下文无关语言" itemprop="url">MAL-下推自动机与上下文无关语言</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>考前复习+Course work复习, 下推自动机与上下文无关语言部分……土狼：people die if they are killed。</p>

<p>MD还要躺着……戴了护裆都能中招真是……</p>

<embed height="452" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="http://share.acg.tv/flash.swf" flashvars="aid=382643&amp;page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" />

<h1 id="section">上下文无关语言</h1>

<h2 id="context-free-grammar">上下文无关文法(Context-Free Grammar)</h2>

<p>上下文无关文法由一个四元组$G=(V, \Sigma, S, P)$来描述。其中：</p>

<ul>
  <li>$V$ 是变量集合，或者说非停止符号集</li>
  <li>$\Sigma$ 是停止符号集</li>
  <li>$S$ 是起始变量</li>
  <li>$P$ 是语法规则集(rule/productions)，$P$中的元素通常是如下的形式：$A \to
\alpha, A \in V, \alpha \in (V \cup \Sigma)$</li>
  <li>$S \in V$, $V$ 与 $\Sigma$无交集。$V$, $S$, $P$都是有限的。</li>
</ul>

<p>我们使用如下的符号来表示一些推导规则：</p>

<ul>
  <li>$\to$ 表示在语法中的一个生成规则(production), $\Rightarrow$表示根据语法
规则的一步推导(derivation)</li>
  <li>$\alpha \Rightarrow^n \beta$ 表示$n$步推导，$\alpha \Rightarrow^*
\beta$ 表示0或者多步推导。</li>
  <li>$\Rightarrow_G$ 表示根据语法$G$的推导。</li>
</ul>

<p>$\alpha \Rightarrow \beta$ 表示存在字符串$\alpha_1, \alpha_2$, $\gamma \in (V
\cup \Sigma)^*$, 以及生成规则$A \to \gamma \in P$, 使得$\alpha = \alpha_1 A
\alpha_2$, $\beta = \alpha_1 \gamma \alpha_2$</p>

<p>当如上的推导规则可以对于任意可能的$\alpha_1,\alpha_2$都成立时，我们认为该规则是
上下文无关的(context-free)</p>

<h2 id="context-free-language">上下文无关语言(Context-Free Language)</h2>

<p>假设存在一个上下文无关文法(CFG)$G=(V, \Sigma, S, P)$, 由$G$生成的语言
为：
$ L(G) = \lbrace \chi \in \Sigma^* | S \Rightarrow_G^* \chi \rbrace $</p>

<p>当存在一个语言$L$,使得$L = L(G)$, 我们可以说这个语言是上下文无关语言(Context-Free Language)。</p>

<h2 id="kleene">联合，连接与Kleene星号运算</h2>
<p>如果$L_1$, $L_2$都是定义在$\Sigma$上的上下文无关语言，那么$L_1 \cup
L_2, L_1 L_2, L_1^*$都是上下文无关语言。</p>

<p>令$G_1, G_2$分别表示$L_1, L_2$的语法，假设他们之间没有公共变量。$S_1,
S_2$分别是起始变量。</p>

<p>令$S_u, S_c, S_k$分别表示联合，连接与Kleene星号的起始变量，$G_u, G_c,
G_k$表示对应的语法，我们可以创造如下规则使前述定理成立：</p>

<ul>
  <li>对于$G_u$, 向$G_1, G_2$添加规则$S_u \to S_1 | S_2$</li>
  <li>对于$G_c$, 向$G_1, G_2$添加规则$S_c \to S_1 S_2$</li>
  <li>对于$G_k$, 向$G_1$添加规则$S_k \to \Lambda | S_k S_1$</li>
</ul>

<h2 id="derivation-tree">派生树(Derivation Tree)与歧义</h2>

<p>派生树用于表示CFG生成字符串的一般步骤。构建派生树的方法如下：</p>

<ul>
  <li>跟节点用于表示起始变量S</li>
  <li>任何内节点(interior node)与它的子节点表示一个通过推导规则$A \to \alpha$派生产物
该节点表示变量A, 而其子节点，从左至右表示在字符串$\alpha$下的符号</li>
  <li>任何叶结点表示一个符号或者空串</li>
  <li>最终派生的字符串从左到右读入，排除任何的空串</li>
  <li>一个派生方法只能得到一个派生树，而一个派生树可以表示不止一种派生方法</li>
</ul>

<p>在实际应用中，我们通常使用左派生(leftmost derivation)，即对于每一步推
导，我们永远对当前最左边的变量使用派生规则。</p>

<p>我们有如下定理：
如果G是CFG，那么对于所有的$x \in L(G)$, 我们有如下三个表述等价：</p>

<ul>
  <li>$x$ 有多于一个的派生树</li>
  <li>$x$ 有多于一个的左派生树</li>
  <li>$x$ 有多于一个的右派生树</li>
</ul>

<p>我们认为对于一个是CFG的G是有歧义的，当该G存在至少一个$x \in L(G)$, $x$
有多于一个的派生树，或者根据如上定理，有多于一个的左派生树。</p>

<p>典型例子：</p>

<blockquote>
  <p>if (e1) if (e2) f(); else g();</p>
</blockquote>

<p>我们可以通过引入新变量来消除歧义。</p>

<h2 id="simplified-formsnormal-forms">简式(Simplified Forms)与范式(Normal Forms)</h2>

<h2 id="section-1">上下文无关语言的泵引理</h2>

<p>CFL同样有泵引理的应用。令$L$为CFL，那么必然存在一个正整数$n$,使得对于任意的$u
\in L, | u | \geq n$, $u$可以被写成$u=vwxyz$, 而且满足：</p>

<ul>
  <li>$| wy | &gt; 0$</li>
  <li>$| wxy | \leq n$</li>
  <li>$\forall m \geq 0, vw^mxy^mz \in L$</li>
</ul>

<p>（证明待补充）</p>

<h2 id="section-2">泵引理的应用</h2>

<p>我们以$L = \lbrace a^nb^nc^n | n \geq 0 \rbrace$作为例子说明泵引理在证明某个语
言非上下文无关中的应用。</p>

<p>令$u$是一个形如$a^nb^nc^n$的字符串且$| u | \geq n$</p>

<p>我们有$u=vwxyz$满足泵引理之条件。$| wy | &gt; 0$说明字符串$wy$至少有一个符号。$|
wxy | \leq n$说明$wxy$至多含有两个不同的符号。假设$\sigma_1$是一个出现在$wy$中
的符号，$\sigma_2$是不在$wy$中的符号。那么字符串$vw^0xy^0z$同样可以保持$u$的特性，
但是显然$\sigma_1$的数目小于$n$,而$\sigma_2$的数目等于$n$，这与泵引理的第3条特性
矛盾。</p>

 -->
    
        <p>考前复习+Course work复习, 下推自动机与上下文无关语言部分……土狼：people die if they are killed。</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->


<div class="pagination">
  
    
      <a href="http://MeowAlienOwO.github.io/page2" class="btn">Previous</a>
    
  
  <ul class="inline-list">
    <li>
      
        <a href="http://MeowAlienOwO.github.io">1</a>
      
    </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io/page2">2</a>
        
      </li>
    
      <li>
        
          <span class="current-page">3</span>
        
      </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io/page4">4</a>
        
      </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io/page5">5</a>
        
      </li>
    
  </ul>
  
    <a href="http://MeowAlienOwO.github.io/page4" class="btn">Next</a>
  
</div><!-- /.pagination -->

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2016 死鱼眼的喵星人. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="http://mademistakes.com/hpstr/" rel="notfollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://MeowAlienOwO.github.io/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://MeowAlienOwO.github.io/assets/js/scripts.min.js"></script>

<script type="text/javascript" src="/assets/js/vendor/share.min.js"></script>




          

</body>
</html>
