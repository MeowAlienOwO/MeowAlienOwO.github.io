<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>操作系统笔记二：内存管理 &#8211; 喵窝[0]号机</title>
<meta name="description" content="一个伪装成技术博客的吐槽网站。">

<meta name="keywords" content="cs, os, notes">

<!-- other plugins config -->
<!-- mathjax -->
<script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$'], [ '\\(', '\\)']]}});
</script>

<!-- Share.js -->
<link href="/assets/css/share.min.css" rel="stylesheet">
<script type="text/javascript" src="/assets/js/vendor/share.min.js"></script>
<!-- end of plugins -->

<meta http-equiv="content-type" content="text/html; charset=utf-8" />


<!-- Open Graph -->
<!-- <meta property="og:locale" content="en_US"> -->
<meta property="og:locale" content="zh_CN" />
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统笔记二：内存管理">
<meta property="og:description" content="一个伪装成技术博客的吐槽网站。">
<meta property="og:url" content="http://MeowAlienOwO.github.io//computer%20science/operating%20system/operating_system-_memory_management/">
<meta property="og:site_name" content="喵窝[0]号机">





<link rel="canonical" href="http://MeowAlienOwO.github.io//computer%20science/operating%20system/operating_system-_memory_management/">
<link href="http://MeowAlienOwO.github.io//feed.xml" type="application/atom+xml" rel="alternate" title="喵窝[0]号机 Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://MeowAlienOwO.github.io//assets/css/main.css">
<!-- Webfonts -->
<!-- <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css"> -->
<link href="//fonts.useso.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">
<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://MeowAlienOwO.github.io//assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://MeowAlienOwO.github.io//favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://MeowAlienOwO.github.io//favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://MeowAlienOwO.github.io//images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://MeowAlienOwO.github.io//images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://MeowAlienOwO.github.io//images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://MeowAlienOwO.github.io//images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://MeowAlienOwO.github.io//">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://MeowAlienOwO.github.io//images/avatar.png" alt="死鱼眼的喵星人 photo" class="author-photo">
					<h4>死鱼眼的喵星人</h4>
					<p>烈風？いいえ、知らない子ですね。（もぐもぐ</p>

				</li>
				<li><a href="http://MeowAlienOwO.github.io//about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:meowalienowo@outlook.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				
				
				
				
				<li>
					<a href="http://github.com/https://github.com/MeowAlienOwO"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://MeowAlienOwO.github.io//posts/">All Posts</a></li>
				<li><a href="http://MeowAlienOwO.github.io//tags/">All Tags</a></li>
				
				<li>
				  <a href="/categories/hello/">
				    hello (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/jekyll/">
				    jekyll (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Computer Science/">
				    Computer Science (12)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Math/">
				    Math (2)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Operating System/">
				    Operating System (3)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/ACG/">
				    ACG (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/空之境界/">
				    空之境界 (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/C++/">
				    C++ (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Network/">
				    Network (7)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/自言自语/">
				    自言自语 (2)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/日本語/">
				    日本語 (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/japahese/">
				    japahese (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/11区生活/">
				    11区生活 (1)
				  </a>
				</li>
				
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  <div class="image-credit">Image source: <a href="http://www.pixiv.net/member_illust.php?mode=medium&illust_id=27167056">TYPE-MOON10YEARS!! | STAR影法師 [pixiv]</a></div><!-- /.image-credit -->
  <div class="entry-image">
    <img src="http://MeowAlienOwO.github.io//images/27167056.jpg" alt="操作系统笔记二：内存管理">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io//computer%20science/operating%20system/operating_system-_memory_management/" rel="bookmark" title="操作系统笔记二：内存管理">操作系统笔记二：内存管理</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2015-03-30T19:10:06+08:00">March 30, 2015</time></span></h2>
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>操作系统笔记之二，内存管理。每一次上操作系统跟MAL都是智商上的一种煎熬啊……跟上一篇同样，这也是一些翻译ppt的内容，充作笔记。</p>

<h1 id="section">基础知识</h1>
<p>## 硬件存储器层级与操作系统</p>

<p>现代的算机通常有如下几种存储层级，由速度快慢排列如下：</p>

<ol>
  <li>寄存器，1/2/3级缓存</li>
  <li>主内存</li>
  <li>硬盘</li>
</ol>

<p>更高级的存储器更快，但是代价更加昂贵以及更加容易被改变，低级的则相反。
内存可以被认为是一个线性的字节/单词的数组，而操作系统负责提供内存的抽
象。</p>

<p>操作系统负责：</p>

<ol>
  <li>根据进程的请求分配/收回内存</li>
  <li>追踪内存的使用情况</li>
  <li>“透明地”(Transparently)在内存与硬盘之间移动信息</li>
  <li>在进程之间分配内存，模拟”无限大”的内存空间</li>
  <li>多任务的情况下，负责控制权限分配</li>
</ol>

<h2 id="section-1">内存管理模型</h2>

<p>内存管理模型有两种：连续模型与非连续模型。</p>

<p>连续模型将所有的内存看作单个内存块，而非连续模型将内存分为若干内存块，
或者称之为段(segments)。这些段可以在物理内存中的任何位置，而不需要一定与彼此相邻。</p>

<p>至于内存的分区方面，对于单任务系统而言，只需要一个分区即可。而对于多任务系统而言，分区有多种方案。多任务系统可以是动态分区的，也可以是固定分区的。对于固定分区而言，有相等分区与不等分区两种。</p>

<h3 id="section-2">单任务系统</h3>

<p>单任务系统每次只允许一个用户进程在内存中被执行。内存的一部分被操作系统使用，而另外一部分被用户系统所使用(“MS-DOS”方式)。被操作系统所使用的部分一般而言是固定大小的，通常可以直接使用物理内存。</p>

<table border="1">
<tr>
<th>...</th>
<th>用户进程</th>
<th>...</th>
<th>操作系统内核</th>
</tr>
</table>

<p>这种方式没有保护用户进程的必要，因为同一时间只有一个程序在运行。由于一个进程通常使用了所有的内存空间，同一进程通常被分配在同样的内存地址。当然，程序员可以用覆盖的方法来使用更多的空间，但是这种方法看起来更容易造成麻烦。</p>

<p>对于单任务系统而言，它的缺点是显而易见的：
1. 由于用户进程可以直接使用物理内存，它有可能会对操作系统的内存进行读写。
2. 如果我们将操作系统自身看作一个进程的话，实际上有两个进程同时运行(ppt原话翻译，我的理解是这可能是因为虽然是两个进程，但是由于单任务的特性，一次只能运行一个进程，这也意味着操作系统进程在用户进程被激活时是处于suspend状态，结合前面的直接读取权限，很可能用户进程对操作系统内存的读写是没有保护的。另一个问题可能也是进程排程的问题，操作系统进程无法跟用户进程协同。)
3. 对硬件资源的利用率低(比如说IO)
4. 无法适应需要多任务的场景</p>

<p>尽管如此，单任务系统依然在一些基础的嵌入式系统与家电中广泛运用。</p>

<h3 id="section-3">多任务系统</h3>

<p>从另一个角度而言，我们可以通过上下文切换来在单任务系统上模拟多任务：当需要切换进程的时候，将进程信息保存至硬盘，然后将新的进程信息读入并执行。但是这必然带来昂贵的开销。于是，真正的多任务系统就必不可少了。</p>

<p>我们首先做一个假设：进程会使用$p%$的时间来等待IO事务。那么，当内存中有$n$个进程的时候，所有的$n$个进程等待IO的概率为$p^n$，而CPU的利用率为$1 - p^n$。显而易见的，当同时运行的进程越多时，CPU的利用率越高，而当面向IO的进程变多时，CPU的利用率会相对有所降低。</p>

<p>但是，这个假设是建立在所有进程都是相互独立的基础上的，而在现实中，这是不可能的。不过我们仍旧可以用其来进行粗略的估算。</p>

<p>假设一个计算机有1M的内存，操作系统使用了200k，剩下的空间分配给4个200k的进程。那么CPU的利用率就将在60%以下。如果我们增加1M内存，将这些内存分配给5个200k的进程，那么我们的CPU利用率就有了87%。如果我们再增加1M的内存，我们就会得到大于96%的CPU利用率。由此看出，多线程可以很有效地提高资源利用率。</p>

<h4 id="section-4">固定分区（同等大小）</h4>

<p>固定分区方法将所有用于用户进程的内存分成固定大小的若干个段，这些段拥有固定大小以及固定的位置。</p>

<p>优点：</p>

<ul>
  <li>任何进程都可以使用任何足够大的分区</li>
  <li>开销较小，同时实现简单</li>
  <li>操作系统只需要追踪被使用的区块与空闲的区块即可</li>
</ul>

<p>缺点：</p>

<ul>
  <li>内存利用率相对较低，内部碎片化程度(internal fragmentation)在分区过大的情况下会很高，分区可能会过大</li>
  <li>如果程序太大，需要重写内存（折腾程序员）</li>
  <li>分区过小，追踪、分配的开销会变得很大</li>
</ul>

<p>同时，固定分区还需要考虑如何将区块分配给任务，如何决定交换等。于是我们需要一些其他的策略来解决这些问题。</p>

<h4 id="section-5">固定分区改（不同等大小）</h4>

<p>不同等大小分区策略将分区分成大小不同的几个固定区块，这样做的好处是可以增加内存使用率，以及可以更加灵活地分配资源。内部碎片化的程度也因此可以得到控制。相对的，对于不同等大小分区而言，我们需要考虑的是如何将合适的分区分配给相对应的进程。</p>

<p>一种策略是，对于每个分区，我们设置一个私有队列，每次分配进程时，将其安排在空间足够大，且最小的分区:<code>p.size &lt; m.size &amp;&amp; m.isMin</code>。这种策略，由于每次都能保证进程分配的分区足够且最小，内部碎片度会很有效地减少。但是相对的，内存使用率就会下降（总是将进程分配给最小的段），以及会导致饥饿的发生。</p>

<p>另一种策略则将队列设为全局的，对于每一个进程，分配给当前可用的、装的下的最小队列:<code>p.size &lt; m.size &amp;&amp; m.isAvailable &amp;&amp; m.isMin</code>。
这种策略没有那么容易饥饿(可以将小程序分给大分区)，然而相对的，内部碎片化程度也会相对提高。</p>

<p>另一方面，我们需要注意的是，对内存需求的计算依赖于在程序开始时的估算，而程序的内存需求可能会随着运行而改变。同时，我们也无从预先得知程序运行时内存的分配情况。而进程更可能会被交换(swap)出去，然后被重新载入。那么，我们需要动态的去改变内存分配。</p>

<h1 id="section-6">地址管理</h1>

<h2 id="section-7">基础知识</h2>

<ul>
  <li>
    <p>相对分配(relocation)：操作系统无法在程序运行之前预先知道这个程序的分区与地址。这就意味着操作系统不能简单地静态地分配绝对地址，而相对的，地址必须根据运行时的情况进行相对分配。</p>
  </li>
  <li>
    <p>保护：当有复数的程序在内存中运行时，必须进行保护。</p>
  </li>
  <li>
    <p>逻辑地址(logical address)是进程所知道的内存形式。其独立于当前的物理内存，比如同程序的开始地址相对。</p>
  </li>
  <li>
    <p>物理地址(physical address)表示在主内存中的实际地址。逻辑地址空间必须以某种方式映射到物理地址空间上。</p>
  </li>
</ul>

<h2 id="section-8">管理方法</h2>

<ul>
  <li>编译时静态相对分配内存：一个进程每次都会被放在相同的地址</li>
  <li>在载入时动态相对分配内存：逻辑地址是相对的，每次载入的时候通过计算偏移量来分配内存块。这会使载入变慢。</li>
  <li>运行时动态分配内存</li>
</ul>

<p>在CPU中，有两个特殊的寄存器用来存储基准地址(base address)与极限(limit)。基准寄存器用于储存分区的开始地址(start address)，极限寄存器用来存储分区的极限</p>

<p>运行时，基准寄存器的地址加上逻辑地址就可以得出物理地址，得出的结果会同极限寄存器中储存的值进行比较来判断是否有效。这种方式需要硬件支持。</p>

<p>固定分区会导致内部碎片(internal fragmentation)：与进程需求完全一致的分区可能不存在，那么空间就有可能没有被完全使用。于此相反，动态分区可以动态地改变内存的开始地址与极限地址。同时，一个进程通常会被分配一块与其内存需求完全相符的连续地址，这就很有效的减少了内存的碎片化程度。</p>

<h2 id="swapping">交换(swapping)</h2>

<p>交换可以将进程的一部分信息保存在硬盘里，然后在主内存跟硬盘之间交换信息。</p>

<p>我们需要使用交换的理由如下：</p>

<ul>
  <li>我们可能有多余分区数的进程数量（假设我们使用固定分区方法）</li>
  <li>总内存的需求大于空余内存需求</li>
  <li>一些进程只是偶尔运行</li>
  <li>进程的内存需求可能会改变</li>
</ul>

<p>外部碎片：
进程的交换也可能会导致内存的碎片化。将一个进程交换出去时，内存中会留下来一个“洞”，当另外的程序使用这个”洞”时，可能并没有使用整个空间，这样一来就会导致一些小小的，没有使用过的内存碎片。同时，一个新进程可能对于这个空间而言过大，那么就有可能导致这个空间自身成为一个碎片。另一方面，对于内存压缩来说，寻找这些碎片的代价也是非常高昂的，同时也需要动态的相对内存分配。</p>

<p>现在，内存管理的问题是：</p>

<ul>
  <li>如何快速地将可用的内存分配给进程</li>
  <li>如何追踪内存的使用-&gt;链表/表</li>
</ul>

<h2 id="section-9">动态分区</h2>

<p>我们需要一个更加复杂的内存分配数据结构来处理可变的使用与空闲的分区数量。</p>

<h3 id="section-10">链表</h3>
<p>链表是一个可以实现如此的数据结构。示意图如下：</p>

<table border="1">
<tr><th>入口指针</th></tr>

<tr>
<th>是否空闲？</th>
<th>开始地址</th>
<th>大小</th>
<th>next指针</th>
</tr>
<tr>...</tr>
<tr>
<th>是否空闲？</th>
<th>开始地址</th>
<th>大小</th>
<th>next指针</th>
</tr>
<tr>...</tr>
<tr>
<th>是否空闲？</th>
<th>开始地址</th>
<th>大小</th>
<th>next指针(结束)</th>
</tr>
</table>

<h4 id="first-fit-algorithm">第一匹配算法(first fit algorithm)</h4>

<p>在初始化的时候，整个内存被认为是一整块，标记为空闲(free)。</p>

<p>当请求内存时，遍历整个链表，直到找到一个足够大的空闲空间。如果这个空间恰好需求相等时，将这块空间标记为使用(used)。如果这块空间比需求的空间大，将接下来的空间切分成另一块链表的节点，标记为空闲。当一块内存被释放时，该内存被设定为空闲。</p>

<h4 id="second-fit-algorithm">匹配算法改-第二匹配算法(second fit algorithm)</h4>

<p>第一匹配算法的近代化改修型。</p>

<p>第一匹配算法在第一次请求内存时开始进行扫描，而第二匹配算法保存一个当前搜索位置的指针。第二次搜索时，从上一次扫描的结尾开始。这种算法可以保证所有的内存块都被扫描。但是第二匹配算法在实验中表现出来的效率比第一匹配差。</p>

<h4 id="best-fit-algorithm">匹配算法改二-最佳匹配算法(best fit algorithm)</h4>

<p>第一匹配只匹配第一个<strong>足够大</strong>的空间，假设在之后的链表中存在一个恰好符合的空间，那么就会导致内存碎片的出现。</p>

<p>最佳匹配算法总是选择一个大小最适合的区块进行分配。然而，由于搜索的存在，必然会导致整个算法的速度降低。同时，令人惊讶的是，这种算法也会导致更高的内存浪费——每个“最合适”的区块万一不是恰好，就会被分割出一块最小的空间。</p>

<h4 id="worst-fit-algorithm">配算法改三-最差匹配算法(worst fit algorithm)</h4>

<p>为了防止最佳匹配算法所导致的大量碎片内存，最差匹配算法每次都会选择一块最大的内存，这样子切分下来的内存就通常会有更高的可用性。</p>

<p>然而在实际应用中似乎并没有什么卵用。</p>

<h4 id="section-11">快速匹配与其他算法</h4>

<p>快速匹配大致是保存一份链表，里面分别保存固定大小的内存块，
比如4byte,8byte……对于一个内存请求而言，寻找最接近的一块内存分配/
如果是奇数大小的内存，或者寻找最近，或者在一个独立的表中处理内存。</p>

<h3 id="bitmap">点阵(bitmap)</h3>

<p>作为链表的一种补充，点阵也是一种有效的数据结构。</p>

<p>这些内存方法同样还有一些其它问题，比如进程运行时会请求更多内存等，
我们需要动态的内存分配方法。</p>

<h1 id="paging">分页(Paging)</h1>

<p>分页是基于固定分区(fixed partitioning)与代码重分配(code re-location)来的非连续内存管理方案。</p>

<ul>
  <li>内存被分成很小的块(4kb左右)，每个进程被分配不止一个块</li>
  <li>内存块不必物理上连续，但是进程仍然认为他们是连续的</li>
</ul>

<p>同如上介绍的连续内存管理方案相比，分页方法有如下好处：</p>

<ul>
  <li>内部碎片只会发生在最后的内存块</li>
  <li>没有外部碎片，物理上所有的内存块都以栈的形式一个连着一个存储</li>
</ul>

<h2 id="section-12">定义</h2>

<p>一个页(page)是一个在逻辑地址空间(logical address space)上的连续小内存块。</p>

<p>相对的，一个帧(frame)是一个在物理内存(physical memory)上连续小内存块。</p>

<p>通常页与帧具有相同的大小，为2的指数，大致在512byte与1Gb之间。</p>

<h2 id="relocation">重分配(relocation)</h2>

<p>逻辑地址需要被转换成物理地址，对于每一个页，我们需要一个基寄存器(base register)
来存储相对的帧所在的地址位置。显而易见的我们需要复数的基寄存器，这些寄存器被存储在分页表(page table)中。
分页被视为一个将页编号与帧编号一一对应的函数映射，我们有：</p>

<p>$frameNum = f(pageNum)$</p>

<p>页面数字被用作分页表的索引(index)，存储其相对应的帧在内存中的顺序。</p>

<p>每一个进程都有他们自己的分页表，存储他们自己的基寄存器。</p>

<p>操作系统维护一个空闲帧的列表。</p>

<h2 id="section-13">地址转换的实现</h2>

<p>一个逻辑地址是想对于程序的开始而言的，其包含两个部分：</p>

<ul>
  <li>左边n个比特位存储页的序数</li>
  <li>右边m个比特位存储在页中的偏移量(offset)</li>
</ul>

<p>物理地址拥有与逻辑地址相同的格式，他们之间的转换由分页表实现。</p>

<p>地址转换的步骤：</p>

<ol>
  <li>将页序数从逻辑表中取出</li>
  <li>使用页序数在分页表中寻找帧序数</li>
  <li>将偏移量加到帧的基寄存器上</li>
</ol>

<p>地址转换的硬件实现：</p>

<ol>
  <li>CPU的内存管理单元(memory management unit)用于拦截(intercept)(?)逻辑地址</li>
  <li>使用分页表进行地址转换</li>
  <li>得出的物理地址被放入内存总线(memory bus)</li>
</ol>

<h1 id="virtual-memory">虚拟内存(virtual memory)</h1>

<p>分页依然存在一些问题：</p>

<ul>
  <li>代码的执行与数据结构被分解成很小的子集</li>
  <li>在同一时刻，不是所有的页面都需要被读入内存，只有在需求时才读入</li>
</ul>

<p>所以我们引入虚拟内存方法。虚拟内存指只有在需要的时候将对应的程序信息读入内存，
但是对于程序而言，它所”看”到的仍然是一整块可用的内存。</p>

<p>虚拟内存允许逻辑地址空间大于物理内存空间。理论上，64位机器可以支持$2^64$个逻辑地址。
这意味着机器有更大的空间容纳更多的进程，而更多的进程可以提高CPU使用率。</p>

<h2 id="page-fault">页面错误(page fault)</h2>

<p>页面错误是指在运行过程中，发现所需要的地址并不在内存中而引发的一个异常，通常作为虚拟内存的交换机制的触发器。
页面错误会导致一个中断(interrupt)，进程进入阻塞状态(blocked state)。操作系统触发一个IO操作，
将不存在的页面读入内存，这里可能会发生上下文切换。IO操作处理完了以后，发出一个中断信号表明IO操作完成，
进程进入准备状态。常驻集(resident set)用于表示被读入主内存的页面。</p>

<p>处理页面错误的流程：</p>

<ol>
  <li>操作系统陷阱(trap operating system)
    <ul>
      <li>储存当前的寄存器与进程状态</li>
      <li>分析中断，例如页面错误</li>
      <li>合法化页面引用，确定页位置</li>
      <li>处理IO事务：队列，寻找，延迟，转换</li>
    </ul>
  </li>
  <li>(可能的)上下文切换</li>
  <li>中端等待IO完成
    <ul>
      <li>存储进程状态/寄存器</li>
      <li>分析磁盘终端</li>
      <li>更新分页表与在内存中的页面</li>
      <li>等待原先的进程被排入时间表</li>
    </ul>
  </li>
  <li>上下文切换至原先的进程</li>
</ol>

<h2 id="section-14">分页表的内容</h2>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>other</td>
        <td>caching</td>
        <td>referenced</td>
        <td>modified</td>
        <td>protection</td>
        <td>present/absent</td>
        <td>frame num</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<ul>
  <li>”出席/缺席“位(present/absent bit)用于指示是否在内存中</li>
  <li>“更改”位(modified bit)用于表示页面是否经过更改</li>
  <li>“引用”位(referenced bit)用于表明页面是否在使用</li>
  <li>“保护”域(protection bits)用于表明页面的读写执行权限</li>
  <li>“缓存”位(caching bit)用于表明页面是否写入设备寄存器</li>
</ul>

<h2 id="section-15">处理大型分页表</h2>

<p>在16bit机器上，地址空间为2^16，假设一个页面为2^10bit,剩下6bit用于标记页面序数，总共可以维护64个页面表。
32bit机器上，一个页面为4kb(2^12)，有20位可以标记页面，总共维护的数量大约为100000。64bit机器拥有更加大量的页面数量。
如何处理更大的页面数量，是一个问题。</p>

<p>首先，对如此大的分页表，将其存储在寄存器不是一个好选择。我们选择将其放在主内存中(虚拟内存)。</p>

<ul>
  <li>多级分页表(multi-level page table)</li>
  <li>逆分页表(inverted page table)</li>
</ul>

<p>另一个需要考虑的是处理时间，由于每次分页都需要进行转换，速度必须足够快。</p>

<h3 id="section-16">多级分页表</h3>

<p>这是一个简单的实现方式。考虑一个32位机器，对于每一个地址，我们使用10bit的PT1域，10bit PT2域，12bit的偏移量。令页面大小4k，总共2^20个页面。</p>

<p>多级分页表不将所有的页面全部放在内存中，在如上例子中，我们将分页表分为两个层级，每个分页表都有2^10项，第一层分页表只有一个，对应1024个子分页表，在地址上我们使用PT1域。第二层分页表有1024个，每个对应1024个页面，使用PT2域。得到目标地址的方法：</p>

<ol>
  <li>PT1+顶层表指针得到第二层表指针</li>
  <li>第二层表指针+PT2得到帧序号</li>
  <li>帧序号+偏移量得到目标物理地址</li>
</ol>

<p>对于任意一个地址，我们只需要保存第一层与相对的第二层表即可。
处理时间：
$L * T + C$,</p>

<p>L 表示层级数， T表示处理每个表的时间，C表示剩余的常数项。</p>

<p>当表已经在内存中时，寻找时间会变成原来的3倍(加上处理两个表)</p>

<h3 id="tlb">TLB</h3>

<p>我们使用传输后备缓冲器TLB(Translation Look aside Buffer)来对一些经常使用的页面与表的入口进行缓存。
页面表的搜索与TLB中的搜索是平行的。
TLB同其他的缓存没有什么不同。</p>

<p>搜索算法：</p>

<ol>
  <li>同时搜索TLB与分页表</li>
  <li>如果TLB中搜索到，直接得出帧序号+偏移量(TLB Hit)</li>
  <li>如果不在TLB中，搜索分页表得到帧序号(TLB Miss)</li>
</ol>

<p>假设我们需要20ns在TLB中寻找，内存处理时间100ns</p>

<p>对于单层表而言,TLB Hit时间为20 + 100ns(TLB搜索时间+内存)
TLB Miss时间为20 + 100 + 100ns(TLB搜索时间+分页表搜索时间+内存)</p>

<h3 id="section-17">逆分页表</h3>

<p>一个“正”分页表的大小同虚拟空间大小对应，而一个“逆”分页表同主内存的大小对应。
逆分页表通过哈希函数来得到页面数字，而且使用帧序号作为索引。</p>

<h3 id="thrashing">击打(Thrashing)</h3>

<p>假设所有的可以使用的表都在被活跃地使用，读入一个新的内存表时，这个表需要马上被交换出来，然后很快被读回去。</p>

<p>击打发生在某块内存被交换出去，然后马上被读入的时候，使得CPU使用率下降
CPU使用率下降会导致多任务程度上升，而多任务程度上升会进一步增加IO事务，减低CPU使用率。</p>

<p>击打的原因包括：</p>

<ul>
  <li>过高的多任务程度</li>
  <li>单个进程被分配的页面太少</li>
</ul>

<p>我们可以使用减低多任务率以及使用一个更好的页面替换策略来防止击打的发生。</p>

<h1 id="page-replacing-algorithms">页面替换算法(Page-replacing Algorithms)</h1>

<h2 id="demand-paging">页面请求(demand paging)</h2>

<p>令ma, p, pft表示内存处理时间(memory access time)，页面错误率(page fault rate)，页面错误处理时间(page fault time)，
总处理时间(access time)为:</p>

<p>$(1 - p) * ma + pft * p$</p>

<p>一般而言处理时间与页面错误率成正比。</p>

<p>虚拟内存依赖于共用页面组的位置。进程从一个位置移向另一个，如果所有需求的页面都在内存中，就不会出现页面错误。</p>

<p>页面请求从内存中没有页面开始，第一个指令会马上导致页面错误。之后，页面错误数量会增加，但是最终会维持在一个稳定的水平。</p>

<h2 id="pre-paging">页面预载入(Pre-paging)</h2>

<p>当进程开始后，所有被预计所要使用的页面(工作集，working set)会一次性被读入内存。这将减少页面错误数量，而且减少转换所需时间。</p>

<p>预载入在页面错误产生之前发生，经常被用在进程被交换的时候。</p>

<h2 id="section-18">页面替换算法</h2>

<p>当一个新的页面载入时，操作系统需要选择一个页面来移除。这个选择是由页面替换算法所决定的。
这个算法需要考虑时间成本以及防止击打。</p>

<h3 id="optimal-pae-replacement">最优页面替换(optimal pae replacement)</h3>

<p>每一个页面都有一个接下来需要执行的操作/接下来再被调用所需要的时间长度的列表，将最长时间不用的页面交换出去。
这个算法在实现上是不可能的。但是这可以被提前执行分析所应用，也可以提供一个页面错误数量的下界。</p>

<h3 id="not-recently-used-nru">最近未使用(not recently used, NRU)</h3>

<p>NRU使用引用比特位与更改比特位来寻找下一个页面。在开始的时候，所有的引用比特位都设置未0，并且周期性地重置为0。
当页面错误发生时，操作系统检查分页表，根据这两个比特位的取值，分成四种页面类型(page class):</p>

<ol>
  <li>无引用，无更改</li>
  <li>无引用，有更改</li>
  <li>有引用，无更改</li>
  <li>有引用，有更改</li>
</ol>

<p>NRU算法从编号低的类型开始，选取第一个非空类型中的一个任意页面移除。</p>

<p>NRU的性能尚可，对于理解与实现而言也相对简单。</p>

<h3 id="section-19">先进先出</h3>

<p>先进先出维护一个链表，新的页面会加入链表的末端。
每次交换的时候交换链表头的元素。这是一个简单的实现，但是会有比较糟糕的性能：它不知道哪些页面被经常使用。</p>

<p>有改进型第二选择FIFO(second chance FIFO)</p>

<p>如果一个页面在链表的前面且引用位为0，则将其交换；如果引用位非0，将这个页面放在链表的最后，重置其引用位。</p>

<p>这个算法依然比较简单，但是开销非常大。同时，当所有的页面被引用时，它会退化为平凡的FIFO算法</p>

<h3 id="clock-replacement-algorithm">时钟替换算法(clock replacement algorithm)</h3>

<p>将第二选择FIFO的链表首尾相连就成为时钟替换算法。我们保存一个指针指向最老的页面。这个算法中，指针只能想一个方向移动。</p>

<p>这个算法效率更高，但是当链表很长的时候表现依然糟糕。</p>

<h3 id="least-recently-used-lru">最近少使用(least recently used, LRU)</h3>

<p>最近少使用算法移除一个距今最长时间不用的页面。操作系统必须追踪页面上一次被使用距今的时间，每个分页表入口有一块区域来存储计数器。
这个实现的开销也不小，因为我们需要维护一个根据时间排序的页面列表(或者搜索)。</p>

<p>这个算法可以在硬件层面加入一个计时器实现。</p>

<h2 id="paging-daemons">页面守护进程(Paging daemons)</h2>

<p>实际上，保存一些空闲的页面来应对未来可能发生的页面错误更加经济有效。许多系统现在有一个后台的页面守护进程，这些进程周期性地运行。
当空闲的页面太少时，会使用页面交换算法选取若干页面交换出去。</p>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://MeowAlienOwO.github.io//tags/#cs" title="Pages tagged cs" class="tag"><span class="term">cs</span></a><a href="http://MeowAlienOwO.github.io//tags/#os" title="Pages tagged os" class="tag"><span class="term">os</span></a><a href="http://MeowAlienOwO.github.io//tags/#notes" title="Pages tagged notes" class="tag"><span class="term">notes</span></a></span>
        
        <div class="social-share" >
  <!-- <ul class="socialcount socialcount-small inline-list"> -->
  <!--   <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://MeowAlienOwO.github.io//computer%20science/operating%20system/operating_system-_memory_management/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li> -->
  <!--   <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://MeowAlienOwO.github.io//computer%20science/operating%20system/operating_system-_memory_management/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li> -->
  <!--   <li class="googleplus"><a href="https://plus.google.com/share?url=http://MeowAlienOwO.github.io//computer%20science/operating%20system/operating_system-_memory_management/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li> -->
  <!-- </ul> -->
</div><!-- /.social-share -->

      </footer>
    </div><!-- /.entry-content -->
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://MeowAlienOwO.github.io//c++/%E5%AE%89%E8%A3%85sdl/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://MeowAlienOwO.github.io//11%E5%8C%BA%E7%94%9F%E6%B4%BB/%E4%BD%9C%E6%AD%BB%E7%AC%AC%E4%B8%80%E5%91%A8/" title="作死第一周">作死第一周</a></h3>
      <p>嘛...被老司机秀了一脸._.首先，在日语荒废好几个月以后不知死活地跑路到立本……然后开始了在这里的实习……仔细想想，我前几个月不应该在实习上面浪费太多时间的……应该关在某个小黑屋里学日语……不然现在也不会这么尴尬……无论如何，现在整理一下目前的状态……# 目前状态## 语...&hellip; <a href="http://MeowAlienOwO.github.io//11%E5%8C%BA%E7%94%9F%E6%B4%BB/%E4%BD%9C%E6%AD%BB%E7%AC%AC%E4%B8%80%E5%91%A8/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://MeowAlienOwO.github.io//japahese/%E5%96%B5%E7%9A%84%E5%AE%8C%E7%BE%8E%E6%97%A5%E8%AF%AD%E6%95%99%E5%AE%A4/" title="喵的完美日语教室">喵的完美日语教室</a></h4>
        <span>Published on January 11, 2016</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://MeowAlienOwO.github.io//%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/%E5%9B%9E%E5%BD%92/" title="回归">回归</a></h4>
        <span>Published on January 09, 2016</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
    <section id="disqus_thread"></section><!-- /#disqus_thread -->

  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2016 死鱼眼的喵星人. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="http://mademistakes.com/hpstr/" rel="notfollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://MeowAlienOwO.github.io//assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://MeowAlienOwO.github.io//assets/js/scripts.min.js"></script>

<script type="text/javascript" src="/assets/js/vendor/share.min.js"></script>




    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'meowalienowogithubio'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script'); s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

	        

</body>

</html>
