<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Entry &#8211; 喵窝[0]号机</title>
<meta name="description" content="一个伪装成技术博客的吐槽网站。">

<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- mathjax -->
<script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$'], [ '\\(', '\\)']]}});
</script>


<meta http-equiv="content-type" content="text/html; charset=utf-8" />


<!-- Open Graph -->
<!-- <meta property="og:locale" content="en_US"> -->
<meta property="og:locale" content="zh_CN" />
<meta property="og:type" content="article">
<meta property="og:title" content="Entry">
<meta property="og:description" content="一个伪装成技术博客的吐槽网站。">
<meta property="og:url" content="http://MeowAlienOwO.github.io//page2/index.html">
<meta property="og:site_name" content="喵窝[0]号机">





<link rel="canonical" href="http://MeowAlienOwO.github.io//page2/">
<link href="http://MeowAlienOwO.github.io//feed.xml" type="application/atom+xml" rel="alternate" title="喵窝[0]号机 Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://MeowAlienOwO.github.io//assets/css/main.css">
<!-- Webfonts -->
<!-- <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css"> -->
<link href="//fonts.useso.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">
<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://MeowAlienOwO.github.io//assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://MeowAlienOwO.github.io//favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://MeowAlienOwO.github.io//favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://MeowAlienOwO.github.io//images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://MeowAlienOwO.github.io//images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://MeowAlienOwO.github.io//images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://MeowAlienOwO.github.io//images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://MeowAlienOwO.github.io//">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://MeowAlienOwO.github.io//images/avatar.png" alt="死鱼眼的喵星人 photo" class="author-photo">
					<h4>死鱼眼的喵星人</h4>
					<p>烈風？いいえ、知らない子ですね。（もぐもぐ</p>

				</li>
				<li><a href="http://MeowAlienOwO.github.io//about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:meowalienowo@outlook.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				
				
				
				
				<li>
					<a href="http://github.com/https://github.com/MeowAlienOwO"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://MeowAlienOwO.github.io//posts/">All Posts</a></li>
				<li><a href="http://MeowAlienOwO.github.io//tags/">All Tags</a></li>
				
				<li>
				  <a href="/categories/hello/">
				    hello (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/jekyll/">
				    jekyll (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/computer science/">
				    computer science (11)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/math/">
				    math (2)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/operating system/">
				    operating system (2)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/acg/">
				    acg (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/空之境界/">
				    空之境界 (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/c++/">
				    c++ (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/network/">
				    network (7)
				  </a>
				</li>
				
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  <div class="image-credit">Image source: <a href="http://www.pixiv.net/member_illust.php?mode=medium&illust_id=22958285">ZERO | STAR影法師 [pixiv]</a></div><!-- /.image-credit -->
  
    <div class="entry-image">
      <img src="http://MeowAlienOwO.github.io//images/22958285.jpg" alt="Entry">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>喵窝[0]号机</h1>
      <h2>一个伪装成技术博客的吐槽网站。</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io//computer%20science/network/physical_layer/" title="Physical Layer"><img src="http://MeowAlienOwO.github.io//images/49604772.jpg" alt="Physical Layer"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-14T20:15:47+08:00"><a href="http://MeowAlienOwO.github.io//computer%20science/network/physical_layer/">May 14, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io//about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io//computer%20science/network/physical_layer/" rel="bookmark" title="Physical Layer" itemprop="url">Physical Layer</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>第二篇……不要怂就是干…… おかわり！</p>

<h1 id="section">简介</h1>
<p>物理层定义了电子，时间以及其接口的二进制数据通过信道以信号形式传输的方法。
物理层是网络的基础，其属性，比如流量，延迟与错误率决定了网络的性能。
由于物理极限的存在，网络传输数据的量是有极限的。</p>

<p>两个重要概念：</p>

<ul>
  <li>数字模块化(digital modulation)：模拟信号(analog signals)与数字信号(digital bits)之间是如何
转化的</li>
  <li>多路传输方案(multiplexing schemes)：探索如何将多个会话同时在一个传输中介中传输，同时不互相影响。</li>
</ul>

<h2 id="section-1">数据传输的一般过程</h2>

<ol>
  <li>数据分割，封装成数据包</li>
  <li>数据包转化成二进制流</li>
  <li>二进制流转换成数字信号</li>
  <li>数字信号通过相关元件转化成模拟信号</li>
  <li>模拟信号进入网络传输</li>
</ol>

<h1 id="section-2">传输介质</h1>

<ul>
  <li>非屏蔽双绞线(Unshielded twisted pair)：最便宜普遍的传输介质，有不同的规格，最多在100米的距离上起作用。
两条铜导线以一定规格相互缠绕，双方的电磁辐射会互相抵消。</li>
  <li>同轴电缆(coaxial cable)：从内到外由铜芯(copper core)，绝缘材料(insulating material)，编织外导电体(braided outer conductor),保护塑料层(protective plastic covering)组成。</li>
  <li>光纤(fiber optics)：应用全反射传输信息的方法。内部由两层玻璃构成，外层是塑料包裹。</li>
</ul>

<h2 id="section-3">传输模型</h2>

<ul>
  <li>单向传输(simplex transmission)：数据只能向一个方向传输</li>
  <li>半双向传输(half-duplex transmission)：数据在一个确定的时间点上只能向某一方传输，不过可以实现双向的信息传输。</li>
  <li>双向传输(duplex transmission)：数据可以同时双向传输</li>
</ul>

<h2 id="section-4">长距离传输</h2>
<p>导线电阻导致信号丢失，从而不能进行长距离传输。
持续的振荡信号往往比其他信号传输的更远。</p>

<h1 id="section-5">调制</h1>

<p>调制技术是将数字信号编码为模拟信号的方法。主要有调幅(amplitude modulation,AM)，调频(frequency modulation)，调相(phase modulation)三种方法。
所有这三种方法都需要载波信号(carrier signal)，载波信号使用一个频率来传输数据。</p>

<p>调幅指改变模拟信号的振幅，调频指改变模拟信号的频率，调相(?)指改变模拟信号的相位从而传输信息。</p>

<h2 id="modem">猫(MODEM)</h2>

<p>猫，或曰调制解调器，用于调制数字信号为模拟信号，或者将模拟信号解调制为数字信号。双向传输需要两边都有猫。</p>

<h1 id="line-code">线路码(line code)</h1>
<p>线路码（英语：Line code），有时也称传输码。为了便于数字信号传输，将原始的数据码进行一定的修改就得到了线路码。举例来说，当原始数据中存在长时间连续的1或0时，接收方便很难得知每一位信号的时长，也可能误以为信号传输终结而中断通信。线路码还可增加纠错功能，适应信道的特性。常见的线路码包括AMI码、HDB3码等。</p>

<h2 id="section-6">时钟恢复与不归零编码</h2>

<p>时钟恢复通常在不归零编码中使用，不归零编码详见<a href="http://zh.wikipedia.org/wiki/%E4%B8%8D%E6%AD%B8%E9%9B%B6">这里</a>(为何只要一半带宽？)
以下是介绍：</p>

<h3 id="nrz">NRZ</h3>
<p>在电信学中，不归零编码 (non-return-to-zero line code, NRZ) 指的是一种二进制的讯号代码，在这种传输方式中，1 和 0 都分别由不同的电子显著状态来表现，除此之外，没有中性状态、亦没有其他种状态。这种脉冲的能量比归零代码要来得密集，但它传输时是不停歇的，这代表同步信号必须在此代码之外独自传输。</p>

<p>在给定一个信号频率的情况下（比如说位元率），NRZ 代码只需要曼彻斯特代码 (Manchester code) 的一半带宽。</p>

<p>当用于异步传输时，由于缺少中性状态，必须依靠其他种机制，来达成在同步传输中使用时钟侦测错误的资料回复工作。</p>

<p>NRZ-Level 本身并非一种同步系统，而更是一种编码方式，因为它可用于同步环境、或异步环境中，也就是不管有没有明确的时钟讯号，都可以运作。所以，讨论 NRZ-Level 编码是否在时钟“跳动 (clock-edge)”或“跳动之间 (between clock-edge)”并非必要的，因为每一个讯号一定都是以给定的时脉来传输的，这就暗示了讯号内在的时脉。真正的问题是，能否在接收端以当初取样时的同样频率重绘该讯号。</p>

<p>然而，由于 NRZ 讯号的脉冲与时钟是一致的，这就很容易看出 NRZ-Level 和其他编码方式的不同，例如前面提到的曼彻斯特代码，它需要明确的时脉资讯（即 N
RZ 和时钟的 XOR 值），还能看出与 NRZ-Mark 和 NRZ-Inverted 等编码的不同。</p>

<p>NRZ的一个常见编码：1 0 1 0 -&gt; H L H L(1 -&gt; 高电平， 0 -&gt; 低电平)
### NRZI
一改变：“1”为物理电平上的改变。“0”为没有改变。</p>

<p>零改变：“0”为物理电平上的改变。“1”为没有改变。</p>

<p>改变发生在当下位元的时钟脉冲前缘。</p>

<p>但是，NRZI 会有长串的 0或1 位元出现，导致时脉回复有困难，可以使用一些编码技巧（例如游长限制）来解决。曼彻斯特代码永远有时脉信号，但传输效率比 NRZI 低。</p>

<p>NRZI 编码被用于磁带的录音、CD的刻录和标准 USB 的传讯。</p>

<p>常见的NRZI编码: 0101 -&gt; H HLLH （高电平为基准，第一个为0表示电平不改变，第二个为1表示改变电平为低，第三个0表示电平不变仍为低，第四个1表示电平改变为高，计算方式为之前电平与当前的XOR）</p>

<h3 id="clock-recovery">时钟恢复(clock recovery)</h3>
<p>我们通常使用接收方与传输方所约定的时钟频率来进行时间同步，从而确定何时对电压进行采样。
简单的来说，所谓时钟恢复就是：根据参考时钟，从数据信号把时钟信号提取出来。相对应的，在信道上只传输串行数据，在信道上并没有时钟信号。数据接收端接收串行数据并进行时钟恢复。–<a href="http://baike.baidu.com/view/3871116.htm">百度百科</a></p>

<h2 id="manchest-encoding">曼彻斯特编码(Manchest Encoding)</h2>

<p>0表示低电平到高电平，1表示高电平到低电平。传输每一个比特简化了时钟恢复，但是同样效率不高–传输数量与传输速度都需要倍增才能达到不归零编码的效果。
好处是可以使用电平的跳变来同步时钟。更多信息见<a href="http://en.wikipedia.org/wiki/Manchester_coed">维基百科</a>，那个例子图很好。</p>

<p>计算曼彻斯特编码时，要使用时钟比特位与编码比特位异或。</p>

<p>曼彻斯特编码的例子：</p>

<p>0101 -&gt; H LH HL LH HL</p>

<p>以太网使用曼彻斯特编码。</p>

<h2 id="baud-rate">波特率(Baud Rate)</h2>

<p>在电子通信领域，波特率（Baud）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。它是对符号传输速率的一种度量，1波特即指每秒传输1个符号，而通过不同的调制方式，可以在一个码元符号上负载多个bit位信息。–<a href="http://zh.wikipedia.org/wiki/%E6%B3%A2%E7%89%B9%E7%8E%87">维基百科</a></p>

<h2 id="framing-error">帧错误(framing error)</h2>

<p>当收发双方以不同的波特率进行通信时，容易出现帧错误的现象。</p>

<h1 id="section-7">数据传输极限</h1>

<h2 id="nyquist-sampling-theroem">Nyquist Sampling Theroem</h2>

<p>一个无噪声的(noiseless/error-free)的介质的最大传输速率：</p>

<ul>
  <li>$D$：数据比率(bit)每秒，bps</li>
  <li>$B$：带宽(hz)</li>
</ul>

<p>对于使用二进制信号的方案而言，</p>

<p>$Data\ Rate = D = 2B$</p>

<p>对于使用K阶信号的方案而言，</p>

<p>$D = 2B\log_2 K$</p>

<h2 id="shannons-theorem">Shannon’s Theorem</h2>

<p>这个定理针对的是有噪声介质。</p>

<p>信噪比(signal to noise ration)是信号长度与噪声长度之比$S / N$。
信噪比通常用分贝(decibels,db)来表示。$1db = 10 \log_{10} S/N$。</p>

<p>对于有噪声介质的最大数据率为:</p>

<p>$D = B \log_2(1 + S / N)$</p>

 -->
    
        <p>第二篇……不要怂就是干…… おかわり！</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io//computer%20science/network/foundation_of_networking/" title="Foundation of Networking"><img src="http://MeowAlienOwO.github.io//images/46203097.jpg" alt="Foundation of Networking"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-13T16:59:52+08:00"><a href="http://MeowAlienOwO.github.io//computer%20science/network/foundation_of_networking/">May 13, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io//about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io//computer%20science/network/foundation_of_networking/" rel="bookmark" title="Foundation of Networking" itemprop="url">Foundation of Networking</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>考砸了不开心…………………………………………食我酸素鱼雷啦</p>

<p>这个照旧是网络的笔记……John个大坑比……</p>

<h1 id="section">网络基础</h1>

<h2 id="network">何为网络(Network)</h2>

<p>网络是在节点之间传输数据的一种结构。</p>

<ul>
  <li>节点是多种多样的</li>
  <li>节点的数量必须多余两个</li>
</ul>

<p>网络由如下设备组成：</p>

<ul>
  <li>计算设备(computing devices)：主机，终端系统。主要用于运行网络应用。</li>
  <li>传输连接(communication links)：光纤，卫星，广播器等。</li>
  <li>分组交换器(packet switches)：用于传输信息，有路由器(router)与交换器
(switch)两种。</li>
</ul>

<p>互联网：网络的网络，由协议与标准来定义信息的传输。</p>

<h2 id="protocals">互联网协议(protocals)</h2>

<p>互联网协议控制网络信息的发送与接受。协议定义了网络实体之间的信息传输<em>格式</em>，
<em>顺序</em>与对信息传输的<em>行动</em>。</p>

<h2 id="host">主机(host)</h2>

<p>主机以包(packets)的形式传输信息。算法如下：</p>

<ol>
  <li>取得需要传输的信息</li>
  <li>将其截成定长为$L$的小段(chunks)，称之为包(packet)</li>
  <li>将包以某个传输比率(transmission rate)$R$传输至网络</li>
</ol>

<p>传输比率又称连接容量(link capacity)，连接带宽(link bandwidth)，计算公式如下：</p>

<p>$time\ need\ to\ transmit\ L\ bit\ packet\ into\ link = \frac{L(bits)}{R(bits/sec)}$</p>

<h2 id="physical-media">物理媒体(Physical Media)</h2>

<p>比特(bit)：在发送者与接收者之间传输</p>

<p>物理链接(physical link)：连接发送者与接收者的物理材料</p>

<p>导向媒体(guided media)：传输信号的固体媒体，比如铜导线，光纤，同轴电缆</p>

<p>无导向媒体(unguided media)：信号可以自由传播。比如广播。</p>

<h2 id="network-core">网络核心(network core)</h2>

<p>网络核心由一些互相链接的路由器所构成。当主机将应用层的信息转换成包后，将其传输至网络，交给路由器处理，
路由器将收到的包传到下一个路由器。每个包的传输都使用全部的带宽。</p>

<h2 id="section-1">网络结构</h2>

<p>终端系统通过网络服务提供商(Internet Serveice Providers)连接到网络。所有的ISP必须互相之间链接，
这样才能做到路由器之间的通讯。</p>

<p>我们不能将所有的ISP一一相连，这样我们会有$O(n^2)$的连接数目，难于管理。于是出现了ISP的ISP。
但是，不同的高阶ISP又会带来竞争，为了防止竞争造成无法链接的情况，出现了广域网交换点$Internet Exchange Point, IXP$。
同样的，在连接到高阶ISP之前，ISP们之间先组成各种局域网(Regional Network),再通过这些局域网同广域网相连接。同时，如Google, Microsoft之类的内容提供商可以自己组建自己的网络，
使得他们的服务更加快捷地同终端用户相连接。这些网络被称作内容提供网络(content provider network)。</p>

<p>网络的层级如下：</p>

<ol>
  <li>一级网络服务提供商(Tier 1 ISP)与内容提供网络(Content Provider Network)</li>
  <li>广域网交换点(IXP)</li>
  <li>区域ISP</li>
  <li>入口ISP</li>
</ol>

<h2 id="package-switching">封包交换/分组交换(Package switching)</h2>

<p>分组是由一块用户数据和必要的地址和管理信息组成，保证网络能够将数据传递到目标。类似于从邮局发送的包裹上注明的地址一样,只有提供给网络这些信息，网络（邮局）才能把分组（包裹）往正确的地址传送。</p>

<p>分组通过最佳路径(取决于 路由算法)路由到目标。但并不是所有在相同两个主机之间传送的分组（即使是来自同一消息的那些分组）一定要沿着相同的路径传送。</p>

<p>一个数据连接通常传送数据的分组流，它们将不必全部以相同的方式路由过物理网络。目的计算机把收到的所有报文按照适当的顺序重新排列，就能合并恢复出原来的内容。</p>

<p>存储与传输(store-and-forward)：整个包必须在传输到下一个连接之前到达一个路由器。
终端-终端延迟在理想状况下为$2L / R$。</p>

<h3 id="section-2">队列与丢包</h3>

<p>如果路由器的包到达速率超过了其传输速率，那么会发生两种情况：</p>

<ul>
  <li>包被存储在队列中等待，或者</li>
  <li>当队列存储容量满了以后，包会丢失(dropped)</li>
</ul>

<h3 id="section-3">两个关键的的网络核心功能</h3>

<p>路由(routing):决定包的源地址路由器</p>

<p>传输(forwarding):将包从路由的输入转换到正确的输出</p>

<h3 id="circuit-switchingaohu">另一种核心：电路交换(circuit switchingaohu)</h3>

<p>根据
<a href="http://zh.wikipedia.org/wiki/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2" title="电路交换">维基百科</a>的解释，电路交换是在两个通信终端之间建立起一个连接，
双方通过这条通道进行信息的交换。这个连接一直保留到双方的通信结束，在通
信结束之前，连接将始终被占用。这种方式常用在传统的电话网络中。</p>

<h4 id="fdmtdm">电路交换的频分多路复用(FDM)与时分多路复用(TDM)</h4>

<p>频分多路复用(Frequency-division multiplexing)指的是将不同的信息编码至
不同的频率段，从而使得同时可以有多个用户进行通信的技术。频分多路复用在
现代的通信中应用相对较少</p>

<p>时分多路复用(Time-Division Multiplexing)指的是将时间域分成固定的小段，每个小段分配给某个固定的用户
进行通信的技术。典型应用有GSM。</p>

<h3 id="vs-">封包交换 vs 电路交换</h3>

<p>电路交换的最大缺陷是能够服务的用户数量有限，而封包交换往往可以服务更广的用户。</p>

<p>封包交换的优势在于可以共享通信资源以及更加简单(不需要初始化连接)。
但是，封包交换同样存在着延迟与丢包的问题，在需要可信的数据传输的时候，这种方式并不是最好选择。</p>

<h3 id="section-4">丢包与延迟的来源</h3>

<h4 id="section-5">丢包</h4>

<p>路由器使用队列来储存包的请求，当接受速率大于传输速率时，包会被储存进路由器的队列中。当队列容量满时，这时候便无法接受数据包，造成丢包。</p>

<h4 id="section-6">延迟</h4>

<p>对于单路由节点而言，延迟的来源有四个：</p>

<ul>
  <li>节点处理过程(nodal processing)：包含比特错误校验(check bit errors)，确定输出连接等，通常小于毫秒量级</li>
  <li>队列延迟(queueing delay)：等待输出连接的传输时间，由当前连接的拥挤程度而决定</li>
  <li>转换延迟(transmission delay)：将数据输入传输连接的时间，计算方式为$d_{trans} = L / R$,$L$表示包长度，$R$表示带宽</li>
  <li>传输延迟(propagation delay):数据在连接媒体之间传输的时间，计算方式为$d_{prop} = d / s$，$d$表示物理连接的长度，$s$表示传输速度的中位数</li>
</ul>

<p>计算延迟的公式为：</p>

<p>$d<em>{nodal} = d</em>{proc} + d<em>{queue} + d</em>{trans} + d_{prop}$</p>

<h2 id="section-7">层级</h2>

<h3 id="section-8">网络协议层级栈</h3>

<ol>
  <li>应用层(application)：支持网络应用，如FTP, SMTP, HTTP等</li>
  <li>传输层(transport)：进程-进程(process-process)之间的数据传输，TCP，UDP</li>
  <li>网络层(network)：路由相关，如IP，路由协议</li>
  <li>连接层(link)：在相邻网络元素之间的数据传输，如以太网(Ethernet),802.111协议，PPP等</li>
  <li>物理层(physical)：二进制数据</li>
</ol>

<h3 id="isoosi">ISO/OSI七层模型</h3>

<p>在网络协议层级的应用层与传输层之间加入了表示层与会话层。</p>

<ol>
  <li>表示层(presentation)：允许应用解释数据的意义，比如加密，压缩，机器特定的约定，等</li>
  <li>会话层(session)：同步，校验点(checkpoint)，从数据交换中恢复等等</li>
</ol>

<p>一般而言，这两个层级被认为并非绝对必要，且属于应用层的实现。</p>

 -->
    
        <p>考砸了不开心…………………………………………食我酸素鱼雷啦</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io//computer%20science/math/machine_and_their_language(2)/" title="MAL-下推自动机与上下文无关语言"><img src="http://MeowAlienOwO.github.io//images/31958311.png" alt="MAL-下推自动机与上下文无关语言"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-03T14:49:02+08:00"><a href="http://MeowAlienOwO.github.io//computer%20science/math/machine_and_their_language(2)/">May 03, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io//about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io//computer%20science/math/machine_and_their_language(2)/" rel="bookmark" title="MAL-下推自动机与上下文无关语言" itemprop="url">MAL-下推自动机与上下文无关语言</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>考前复习+Course work复习, 下推自动机与上下文无关语言部分……土狼：people die if they are killed。</p>

<p>MD还要躺着……戴了护裆都能中招真是……</p>

<embed height="452" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="http://share.acg.tv/flash.swf" flashvars="aid=382643&amp;page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" />

<h1 id="section">上下文无关语言</h1>

<h2 id="context-free-grammar">上下文无关文法(Context-Free Grammar)</h2>

<p>上下文无关文法由一个四元组$G=(V, \Sigma, S, P)$来描述。其中：</p>

<ul>
  <li>$V$ 是变量集合，或者说非停止符号集</li>
  <li>$\Sigma$ 是停止符号集</li>
  <li>$S$ 是起始变量</li>
  <li>$P$ 是语法规则集(rule/productions)，$P$中的元素通常是如下的形式：$A \to
\alpha, A \in V, \alpha \in (V \cup \Sigma)$</li>
  <li>$S \in V$, $V$ 与 $\Sigma$无交集。$V$, $S$, $P$都是有限的。</li>
</ul>

<p>我们使用如下的符号来表示一些推导规则：</p>

<ul>
  <li>$\to$ 表示在语法中的一个生成规则(production), $\Rightarrow$表示根据语法
规则的一步推导(derivation)</li>
  <li>$\alpha \Rightarrow^n \beta$ 表示$n$步推导，$\alpha \Rightarrow^*
\beta$ 表示0或者多步推导。</li>
  <li>$\Rightarrow_G$ 表示根据语法$G$的推导。</li>
</ul>

<p>$\alpha \Rightarrow \beta$ 表示存在字符串$\alpha_1, \alpha_2$, $\gamma \in (V
\cup \Sigma)^*$, 以及生成规则$A \to \gamma \in P$, 使得$\alpha = \alpha_1 A
\alpha_2$, $\beta = \alpha_1 \gamma \alpha_2$</p>

<p>当如上的推导规则可以对于任意可能的$\alpha_1,\alpha_2$都成立时，我们认为该规则是
上下文无关的(context-free)</p>

<h2 id="context-free-language">上下文无关语言(Context-Free Language)</h2>

<p>假设存在一个上下文无关文法(CFG)$G=(V, \Sigma, S, P)$, 由$G$生成的语言
为：
$ L(G) = \lbrace \chi \in \Sigma^* | S \Rightarrow_G^* \chi \rbrace $</p>

<p>当存在一个语言$L$,使得$L = L(G)$, 我们可以说这个语言是上下文无关语言(Context-Free Language)。</p>

<h2 id="kleene">联合，连接与Kleene星号运算</h2>
<p>如果$L_1$, $L_2$都是定义在$\Sigma$上的上下文无关语言，那么$L_1 \cup
L_2, L_1 L_2, L_1^*$都是上下文无关语言。</p>

<p>令$G_1, G_2$分别表示$L_1, L_2$的语法，假设他们之间没有公共变量。$S_1,
S_2$分别是起始变量。</p>

<p>令$S_u, S_c, S_k$分别表示联合，连接与Kleene星号的起始变量，$G_u, G_c,
G_k$表示对应的语法，我们可以创造如下规则使前述定理成立：</p>

<ul>
  <li>对于$G_u$, 向$G_1, G_2$添加规则$S_u \to S_1 | S_2$</li>
  <li>对于$G_c$, 向$G_1, G_2$添加规则$S_c \to S_1 S_2$</li>
  <li>对于$G_k$, 向$G_1$添加规则$S_k \to \Lambda | S_k S_1$</li>
</ul>

<h2 id="derivation-tree">派生树(Derivation Tree)与歧义</h2>

<p>派生树用于表示CFG生成字符串的一般步骤。构建派生树的方法如下：</p>

<ul>
  <li>跟节点用于表示起始变量S</li>
  <li>任何内节点(interior node)与它的子节点表示一个通过推导规则$A \to \alpha$派生产物
该节点表示变量A, 而其子节点，从左至右表示在字符串$\alpha$下的符号</li>
  <li>任何叶结点表示一个符号或者空串</li>
  <li>最终派生的字符串从左到右读入，排除任何的空串</li>
  <li>一个派生方法只能得到一个派生树，而一个派生树可以表示不止一种派生方法</li>
</ul>

<p>在实际应用中，我们通常使用左派生(leftmost derivation)，即对于每一步推
导，我们永远对当前最左边的变量使用派生规则。</p>

<p>我们有如下定理：
如果G是CFG，那么对于所有的$x \in L(G)$, 我们有如下三个表述等价：</p>

<ul>
  <li>$x$ 有多于一个的派生树</li>
  <li>$x$ 有多于一个的左派生树</li>
  <li>$x$ 有多于一个的右派生树</li>
</ul>

<p>我们认为对于一个是CFG的G是有歧义的，当该G存在至少一个$x \in L(G)$, $x$
有多于一个的派生树，或者根据如上定理，有多于一个的左派生树。</p>

<p>典型例子：</p>

<blockquote>
  <p>if (e1) if (e2) f(); else g();</p>
</blockquote>

<p>我们可以通过引入新变量来消除歧义。</p>

<h2 id="simplified-formsnormal-forms">简式(Simplified Forms)与范式(Normal Forms)</h2>

<h2 id="section-1">上下文无关语言的泵引理</h2>

<p>CFL同样有泵引理的应用。令$L$为CFL，那么必然存在一个正整数$n$,使得对于任意的$u
\in L, | u | \geq n$, $u$可以被写成$u=vwxyz$, 而且满足：</p>

<ul>
  <li>$| wy | &gt; 0$</li>
  <li>$| wxy | \leq n$</li>
  <li>$\forall m \geq 0, vw^mxy^mz \in L$</li>
</ul>

<p>（证明待补充）</p>

<h2 id="section-2">泵引理的应用</h2>

<p>我们以$L = \lbrace a^nb^nc^n | n \geq 0 \rbrace$作为例子说明泵引理在证明某个语
言非上下文无关中的应用。</p>

<p>令$u$是一个形如$a^nb^nc^n$的字符串且$| u | \geq n$</p>

<p>我们有$u=vwxyz$满足泵引理之条件。$| wy | &gt; 0$说明字符串$wy$至少有一个符号。$|
wxy | \leq n$说明$wxy$至多含有两个不同的符号。假设$\sigma_1$是一个出现在$wy$中
的符号，$\sigma_2$是不在$wy$中的符号。那么字符串$vw^0xy^0z$同样可以保持$u$的特性，
但是显然$\sigma_1$的数目小于$n$,而$\sigma_2$的数目等于$n$，这与泵引理的第3条特性
矛盾。</p>

 -->
    
        <p>考前复习+Course work复习, 下推自动机与上下文无关语言部分……土狼：people die if they are killed。</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io//computer%20science/operating%20system/operating_system:_memory_management/" title="操作系统笔记二：内存管理"><img src="http://MeowAlienOwO.github.io//images/27167056.jpg" alt="操作系统笔记二：内存管理"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-03-30T19:10:06+08:00"><a href="http://MeowAlienOwO.github.io//computer%20science/operating%20system/operating_system:_memory_management/">March 30, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io//about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io//computer%20science/operating%20system/operating_system:_memory_management/" rel="bookmark" title="操作系统笔记二：内存管理" itemprop="url">操作系统笔记二：内存管理</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>操作系统笔记之二，内存管理。每一次上操作系统跟MAL都是智商上的一种煎熬啊……跟上一篇同样，这也是一些翻译ppt的内容，充作笔记。</p>

<h1 id="section">基础知识</h1>
<p>## 硬件存储器层级与操作系统</p>

<p>现代的算机通常有如下几种存储层级，由速度快慢排列如下：</p>

<ol>
  <li>寄存器，1/2/3级缓存</li>
  <li>主内存</li>
  <li>硬盘</li>
</ol>

<p>更高级的存储器更快，但是代价更加昂贵以及更加容易被改变，低级的则相反。
内存可以被认为是一个线性的字节/单词的数组，而操作系统负责提供内存的抽
象。</p>

<p>操作系统负责：</p>

<ol>
  <li>根据进程的请求分配/收回内存</li>
  <li>追踪内存的使用情况</li>
  <li>“透明地”(Transparently)在内存与硬盘之间移动信息</li>
  <li>在进程之间分配内存，模拟”无限大”的内存空间</li>
  <li>多任务的情况下，负责控制权限分配</li>
</ol>

<h2 id="section-1">内存管理模型</h2>

<p>内存管理模型有两种：连续模型与非连续模型。</p>

<p>连续模型将所有的内存看作单个内存块，而非连续模型将内存分为若干内存块，
或者称之为段(segments)。这些段可以在物理内存中的任何位置，而不需要一定与彼此相邻。</p>

<p>至于内存的分区方面，对于单任务系统而言，只需要一个分区即可。而对于多任务系统而言，分区有多种方案。多任务系统可以是动态分区的，也可以是固定分区的。对于固定分区而言，有相等分区与不等分区两种。</p>

<h3 id="section-2">单任务系统</h3>

<p>单任务系统每次只允许一个用户进程在内存中被执行。内存的一部分被操作系统使用，而另外一部分被用户系统所使用(“MS-DOS”方式)。被操作系统所使用的部分一般而言是固定大小的，通常可以直接使用物理内存。</p>

<table border="1">
<tr>
<th>...</th>
<th>用户进程</th>
<th>...</th>
<th>操作系统内核</th>
</tr>
</table>

<p>这种方式没有保护用户进程的必要，因为同一时间只有一个程序在运行。由于一个进程通常使用了所有的内存空间，同一进程通常被分配在同样的内存地址。当然，程序员可以用覆盖的方法来使用更多的空间，但是这种方法看起来更容易造成麻烦。</p>

<p>对于单任务系统而言，它的缺点是显而易见的：
1. 由于用户进程可以直接使用物理内存，它有可能会对操作系统的内存进行读写。
2. 如果我们将操作系统自身看作一个进程的话，实际上有两个进程同时运行(ppt原话翻译，我的理解是这可能是因为虽然是两个进程，但是由于单任务的特性，一次只能运行一个进程，这也意味着操作系统进程在用户进程被激活时是处于suspend状态，结合前面的直接读取权限，很可能用户进程对操作系统内存的读写是没有保护的。另一个问题可能也是进程排程的问题，操作系统进程无法跟用户进程协同。)
3. 对硬件资源的利用率低(比如说IO)
4. 无法适应需要多任务的场景</p>

<p>尽管如此，单任务系统依然在一些基础的嵌入式系统与家电中广泛运用。</p>

<h3 id="section-3">多任务系统</h3>

<p>从另一个角度而言，我们可以通过上下文切换来在单任务系统上模拟多任务：当需要切换进程的时候，将进程信息保存至硬盘，然后将新的进程信息读入并执行。但是这必然带来昂贵的开销。于是，真正的多任务系统就必不可少了。</p>

<p>我们首先做一个假设：进程会使用$p%$的时间来等待IO事务。那么，当内存中有$n$个进程的时候，所有的$n$个进程等待IO的概率为$p^n$，而CPU的利用率为$1 - p^n$。显而易见的，当同时运行的进程越多时，CPU的利用率越高，而当面向IO的进程变多时，CPU的利用率会相对有所降低。</p>

<p>但是，这个假设是建立在所有进程都是相互独立的基础上的，而在现实中，这是不可能的。不过我们仍旧可以用其来进行粗略的估算。</p>

<p>假设一个计算机有1M的内存，操作系统使用了200k，剩下的空间分配给4个200k的进程。那么CPU的利用率就将在60%以下。如果我们增加1M内存，将这些内存分配给5个200k的进程，那么我们的CPU利用率就有了87%。如果我们再增加1M的内存，我们就会得到大于96%的CPU利用率。由此看出，多线程可以很有效地提高资源利用率。</p>

<h4 id="section-4">固定分区（同等大小）</h4>

<p>固定分区方法将所有用于用户进程的内存分成固定大小的若干个段，这些段拥有固定大小以及固定的位置。</p>

<p>优点：</p>

<ul>
  <li>任何进程都可以使用任何足够大的分区</li>
  <li>开销较小，同时实现简单</li>
  <li>操作系统只需要追踪被使用的区块与空闲的区块即可</li>
</ul>

<p>缺点：</p>

<ul>
  <li>内存利用率相对较低，内部碎片化程度(internal fragmentation)在分区过大的情况下会很高，分区可能会过大</li>
  <li>如果程序太大，需要重写内存（折腾程序员）</li>
  <li>分区过小，追踪、分配的开销会变得很大</li>
</ul>

<p>同时，固定分区还需要考虑如何将区块分配给任务，如何决定交换等。于是我们需要一些其他的策略来解决这些问题。</p>

<h4 id="section-5">固定分区改（不同等大小）</h4>

<p>不同等大小分区策略将分区分成大小不同的几个固定区块，这样做的好处是可以增加内存使用率，以及可以更加灵活地分配资源。内部碎片化的程度也因此可以得到控制。相对的，对于不同等大小分区而言，我们需要考虑的是如何将合适的分区分配给相对应的进程。</p>

<p>一种策略是，对于每个分区，我们设置一个私有队列，每次分配进程时，将其安排在空间足够大，且最小的分区:<code>p.size &lt; m.size &amp;&amp; m.isMin</code>。这种策略，由于每次都能保证进程分配的分区足够且最小，内部碎片度会很有效地减少。但是相对的，内存使用率就会下降（总是将进程分配给最小的段），以及会导致饥饿的发生。</p>

<p>另一种策略则将队列设为全局的，对于每一个进程，分配给当前可用的、装的下的最小队列:<code>p.size &lt; m.size &amp;&amp; m.isAvailable &amp;&amp; m.isMin</code>。
这种策略没有那么容易饥饿(可以将小程序分给大分区)，然而相对的，内部碎片化程度也会相对提高。</p>

<p>另一方面，我们需要注意的是，对内存需求的计算依赖于在程序开始时的估算，而程序的内存需求可能会随着运行而改变。同时，我们也无从预先得知程序运行时内存的分配情况。而进程更可能会被交换(swap)出去，然后被重新载入。那么，我们需要动态的去改变内存分配。</p>

<h1 id="section-6">地址管理</h1>

<h2 id="section-7">基础知识</h2>

<ul>
  <li>
    <p>相对分配(relocation)：操作系统无法在程序运行之前预先知道这个程序的分区与地址。这就意味着操作系统不能简单地静态地分配绝对地址，而相对的，地址必须根据运行时的情况进行相对分配。</p>
  </li>
  <li>
    <p>保护：当有复数的程序在内存中运行时，必须进行保护。</p>
  </li>
  <li>
    <p>逻辑地址(logical address)是进程所知道的内存形式。其独立于当前的物理内存，比如同程序的开始地址相对。</p>
  </li>
  <li>
    <p>物理地址(physical address)表示在主内存中的实际地址。逻辑地址空间必须以某种方式映射到物理地址空间上。</p>
  </li>
</ul>

<h2 id="section-8">管理方法</h2>

<ul>
  <li>编译时静态相对分配内存：一个进程每次都会被放在相同的地址</li>
  <li>在载入时动态相对分配内存：逻辑地址是相对的，每次载入的时候通过计算偏移量来分配内存块。这会使载入变慢。</li>
  <li>运行时动态分配内存</li>
</ul>

<p>在CPU中，有两个特殊的寄存器用来存储基准地址(base address)与极限(limit)。基准寄存器用于储存分区的开始地址(start address)，极限寄存器用来存储分区的极限</p>

<p>运行时，基准寄存器的地址加上逻辑地址就可以得出物理地址，得出的结果会同极限寄存器中储存的值进行比较来判断是否有效。这种方式需要硬件支持。</p>

<p>固定分区会导致内部碎片(internal fragmentation)：与进程需求完全一致的分区可能不存在，那么空间就有可能没有被完全使用。于此相反，动态分区可以动态地改变内存的开始地址与极限地址。同时，一个进程通常会被分配一块与其内存需求完全相符的连续地址，这就很有效的减少了内存的碎片化程度。</p>

<h2 id="swapping">交换(swapping)</h2>

<p>交换可以将进程的一部分信息保存在硬盘里，然后在主内存跟硬盘之间交换信息。</p>

<p>我们需要使用交换的理由如下：</p>

<ul>
  <li>我们可能有多余分区数的进程数量（假设我们使用固定分区方法）</li>
  <li>总内存的需求大于空余内存需求</li>
  <li>一些进程只是偶尔运行</li>
  <li>进程的内存需求可能会改变</li>
</ul>

<p>外部碎片：
进程的交换也可能会导致内存的碎片化。将一个进程交换出去时，内存中会留下来一个“洞”，当另外的程序使用这个”洞”时，可能并没有使用整个空间，这样一来就会导致一些小小的，没有使用过的内存碎片。同时，一个新进程可能对于这个空间而言过大，那么就有可能导致这个空间自身成为一个碎片。另一方面，对于内存压缩来说，寻找这些碎片的代价也是非常高昂的，同时也需要动态的相对内存分配。</p>

<p>现在，内存管理的问题是：</p>

<ul>
  <li>如何快速地将可用的内存分配给进程</li>
  <li>如何追踪内存的使用-&gt;链表/表</li>
</ul>

<h2 id="section-9">动态分区</h2>

<p>我们需要一个更加复杂的内存分配数据结构来处理可变的使用与空闲的分区数量。</p>

<h3 id="section-10">链表</h3>
<p>链表是一个可以实现如此的数据结构。示意图如下：</p>

<table border="1">
<tr><th>入口指针</th></tr>

<tr>
<th>是否空闲？</th>
<th>开始地址</th>
<th>大小</th>
<th>next指针</th>
</tr>
<tr>...</tr>
<tr>
<th>是否空闲？</th>
<th>开始地址</th>
<th>大小</th>
<th>next指针</th>
</tr>
<tr>...</tr>
<tr>
<th>是否空闲？</th>
<th>开始地址</th>
<th>大小</th>
<th>next指针(结束)</th>
</tr>
</table>

<h4 id="first-fit-algorithm">第一匹配算法(first fit algorithm)</h4>

<p>在初始化的时候，整个内存被认为是一整块，标记为空闲(free)。</p>

<p>当请求内存时，遍历整个链表，直到找到一个足够大的空闲空间。如果这个空间恰好需求相等时，将这块空间标记为使用(used)。如果这块空间比需求的空间大，将接下来的空间切分成另一块链表的节点，标记为空闲。当一块内存被释放时，该内存被设定为空闲。</p>

<h4 id="second-fit-algorithm">匹配算法改-第二匹配算法(second fit algorithm)</h4>

<p>第一匹配算法的近代化改修型。</p>

<p>第一匹配算法在第一次请求内存时开始进行扫描，而第二匹配算法保存一个当前搜索位置的指针。第二次搜索时，从上一次扫描的结尾开始。这种算法可以保证所有的内存块都被扫描。但是第二匹配算法在实验中表现出来的效率比第一匹配差。</p>

<h4 id="best-fit-algorithm">匹配算法改二-最佳匹配算法(best fit algorithm)</h4>

<p>第一匹配只匹配第一个<strong>足够大</strong>的空间，假设在之后的链表中存在一个恰好符合的空间，那么就会导致内存碎片的出现。</p>

<p>最佳匹配算法总是选择一个大小最适合的区块进行分配。然而，由于搜索的存在，必然会导致整个算法的速度降低。同时，令人惊讶的是，这种算法也会导致更高的内存浪费——每个“最合适”的区块万一不是恰好，就会被分割出一块最小的空间。</p>

<h4 id="worst-fit-algorithm">配算法改三-最差匹配算法(worst fit algorithm)</h4>

<p>为了防止最佳匹配算法所导致的大量碎片内存，最差匹配算法每次都会选择一块最大的内存，这样子切分下来的内存就通常会有更高的可用性。</p>

<p>然而在实际应用中似乎并没有什么卵用。</p>

<h4 id="section-11">快速匹配与其他算法</h4>
<p>(存疑，待续)</p>

<h3 id="bitmap">点阵(bitmap)</h3>

<p>作为链表的一种补充，点阵也是一种有效的数据结构。</p>

<p>内存被分割成特定的大小，例如4k。内存如果是空闲的，那么就会在点阵表中
标记为1, 反之为0。</p>

<p>当然，我们需要在内存块大小与点阵表的大小之间做一个恰当的取舍。过小的内存分块会使得搜索点阵变得困难，而过大的内存块分割会导致内部碎片的发生。</p>

<h4 id="coalescing">联合(coalescing)</h4>

<p>当两个相邻的链表中的内存块</p>

 -->
    
        <p>操作系统笔记之二，内存管理。每一次上操作系统跟MAL都是智商上的一种煎熬啊……跟上一篇同样，这也是一些翻译ppt的内容，充作笔记。</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io//c++/%E5%AE%89%E8%A3%85sdl/" title="安装SDL"><img src="http://MeowAlienOwO.github.io//images/8017236.jpg" alt="安装SDL"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-03-28T18:21:11+08:00"><a href="http://MeowAlienOwO.github.io//c++/%E5%AE%89%E8%A3%85sdl/">March 28, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io//about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io//c++/%E5%AE%89%E8%A3%85sdl/" rel="bookmark" title="安装SDL" itemprop="url">安装SDL</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>上课Eugene让我们装个SDL说Coursework要用。嗯，Eugene自己使用Mac的，然后周四的课上又告诉我们怎么在VisualStudio上面装SDL
(虽然我是没搞定，不知道是因为那台电脑跟我冲怎么的)。</p>

<p>……</p>

<p>……</p>

<p>……</p>

<p>Linux呢！?用了Linux不带我玩咯？！</p>

<p><img src="http://MeowAlienOwO.github.io/images/Wuying.jpg" alt="" /></p>

<h1 id="visual-studio-2013">Visual Studio 2013</h1>

<ol>
  <li>
    <p>下载安装包： <a href="https://libsdl.org/download-2.0.php">https://libsdl.org/download-2.0.php</a></p>
  </li>
  <li>
    <p>然后解压，放到一个适当的地方，记下路径 %path%</p>
  </li>
  <li>
    <p>打开Visual Studio，新建一个empty project</p>
  </li>
  <li>
    <p>在整个project上右键之，找到调整property的地方（反正在倒数几排）</p>
  </li>
  <li>在Visual C/C++ properties的地方（反正是这么回事）,找到Includes那一
行加入%path%\includes，找到Libraries那里加入%path%\lib\x86(为了兼容性)</li>
  <li>
    <p>在底下input那里加上SDL2.lib, SDL2main.lib</p>
  </li>
  <li>
    <p>在system那里设为console</p>
  </li>
  <li>
    <p>将压缩包里的dll文件复制到你的项目directory底下</p>
  </li>
  <li>fucking done…</li>
</ol>

<p>可能有记忆不清楚的地方，有空再改……</p>

<h1 id="ubuntu-linux">Ubuntu Linux</h1>

<p>听说包管理器可以搞定：</p>

<p><code>shell
sudo apt-get install libsdl2-dev
</code></p>

<p>听说编译安装可以搞定：</p>

<p>到官网下载源码包，然后make&amp;&amp;make install</p>

<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">hg clone https://hg.libsdl.org/SDL SDL</span>
<span class="go">cd SDL</span>
<span class="go">mkdir build</span>
<span class="go">cd build</span>
<span class="go">../configure</span>
<span class="go">make</span>
<span class="go">sudo make install</span></code></pre></div>

<p>没有hg的话自己装下……</p>

<p>于是我自己手动编译了一遍，不放心又用apt-get装了一遍。</p>

<p>然后挂了。g++可以编译，但是运行的时候返回”No available video device”。</p>

<p>为什么啊！老子按照教程装的啊！</p>

<p>于是开始各种google……有人说ubuntu自带没有x11的dev包……有人说改用i386
的，有人说环境变量没配置好的……</p>

<p>然后在
<a href="https://forums.libsdl.org/viewtopic.php?t=7321&amp;sid=1a10fc21944a39bba3e89eeae4e93b38">这里</a>
看到说:</p>

<blockquote>
  <p>Ubuntu does not ship with several important development headers and
libraries installed. This includes even the basic Xlib stuff, which
is why there is no video driver when you build SDL. You’re going to
need to install all of those yourself. The Software Manager tool
should be convenient here.</p>
</blockquote>

<p><strong>WHAT THE HELL?</strong></p>

<p>老子用了包管理器为何还是这个熊样？</p>

<p>于是接着google……然后看到<a href="http://wiki.libsdl.org/FAQLinux">官方wiki</a>的这个：</p>

<blockquote>
  <p>…if all those didn’t work, and you built SDL from source, make
sure that you have the X11 development libraries installed,
otherwise you’ll get a version of SDL that doesn’t include X11
display support.</p>
</blockquote>

<p>sudo apt-get remove &amp;&amp; make clean…</p>

<p>卸了重装，好了……</p>

<p>目测因为我是先编译安装后用包管理器的，而ubuntu自己本身缺了dev包，
那么我编译的版本也必然是没有dev包的。包管理器装上了x11，
但是库里的东西还是原来的样子，调用的时候是没有x11dev的编译版本。</p>

<p>……</p>

<p><img src="http://MeowAlienOwO.github.io/images/linus-fuck-you.png" alt="" /></p>

<h1 id="mac-os">Mac OS</h1>

<p>哪个土豪送我一个啊啊啊啊啊</p>
 -->
    
        <p>上课Eugene让我们装个SDL说Coursework要用。嗯，Eugene自己使用Mac的，然后周四的课上又告诉我们怎么在VisualStudio上面装SDL
(虽然我是没搞定，不知道是因为那台电脑跟我冲怎么的)。</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->


<div class="pagination">
  
    
      <a href="http://MeowAlienOwO.github.io/" class="btn">Previous</a>
    
  
  <ul class="inline-list">
    <li>
      
        <a href="http://MeowAlienOwO.github.io/">1</a>
      
    </li>
    
      <li>
        
          <span class="current-page">2</span>
        
      </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io//page3">3</a>
        
      </li>
    
  </ul>
  
    <a href="http://MeowAlienOwO.github.io//page3" class="btn">Next</a>
  
</div><!-- /.pagination -->

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2015 死鱼眼的喵星人. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="http://mademistakes.com/hpstr/" rel="notfollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://MeowAlienOwO.github.io//assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://MeowAlienOwO.github.io//assets/js/scripts.min.js"></script>




          

</body>
</html>
