---
layout: post
title: "操作系统笔记二：内存管理"
date: "2015-03-30 19:10:06 +0800"
modified: 
description: 
categories: [Computer Science, Operating System]
tags: [Memory Management, Computer Science, Operating System, notes]
image:
  feature: 27167056.jpg
  credit: TYPE-MOON10YEARS!! | STAR影法師 [pixiv]
  creditlink: http://www.pixiv.net/member_illust.php?mode=medium&illust_id=27167056
comments:
---

操作系统笔记之二，内存管理。每一次上操作系统跟MAL都是智商上的一种煎熬啊……跟上一篇同样，这也是一些翻译ppt的内容，充作笔记。


# 基础知识
## 硬件存储器层级与操作系统

现代的算机通常有如下几种存储层级，由速度快慢排列如下：

1. 寄存器，1/2/3级缓存
2. 主内存
3. 硬盘

更高级的存储器更快，但是代价更加昂贵以及更加容易被改变，低级的则相反。
内存可以被认为是一个线性的字节/单词的数组，而操作系统负责提供内存的抽
象。

操作系统负责：

1. 根据进程的请求分配/收回内存
2. 追踪内存的使用情况
3. “透明地”(Transparently)在内存与硬盘之间移动信息
4. 在进程之间分配内存，模拟"无限大"的内存空间
5. 多任务的情况下，负责控制权限分配

## 内存管理模型

内存管理模型有两种：连续模型与非连续模型。

连续模型将所有的内存看作单个内存块，而非连续模型将内存分为若干内存块，
或者称之为段(segments)。这些段可以在物理内存中的任何位置，而不需要一定与彼此相邻。

至于内存的分区方面，对于单任务系统而言，只需要一个分区即可。而对于多任务系统而言，分区有多种方案。多任务系统可以是动态分区的，也可以是固定分区的。对于固定分区而言，有相等分区与不等分区两种。

### 单任务系统

单任务系统每次只允许一个用户进程在内存中被执行。内存的一部分被操作系统使用，而另外一部分被用户系统所使用("MS-DOS"方式)。被操作系统所使用的部分一般而言是固定大小的，通常可以直接使用物理内存。

<table border="1">
<tr>
<th>...</th>
<th>用户进程</th>
<th>...</th>
<th>操作系统内核</th>
</tr>
</table>


这种方式没有保护用户进程的必要，因为同一时间只有一个程序在运行。由于一个进程通常使用了所有的内存空间，同一进程通常被分配在同样的内存地址。当然，程序员可以用覆盖的方法来使用更多的空间，但是这种方法看起来更容易造成麻烦。

对于单任务系统而言，它的缺点是显而易见的：
1. 由于用户进程可以直接使用物理内存，它有可能会对操作系统的内存进行读写。
2. 如果我们将操作系统自身看作一个进程的话，实际上有两个进程同时运行(ppt原话翻译，我的理解是这可能是因为虽然是两个进程，但是由于单任务的特性，一次只能运行一个进程，这也意味着操作系统进程在用户进程被激活时是处于suspend状态，结合前面的直接读取权限，很可能用户进程对操作系统内存的读写是没有保护的。另一个问题可能也是进程排程的问题，操作系统进程无法跟用户进程协同。)
3. 对硬件资源的利用率低(比如说IO)
4. 无法适应需要多任务的场景

尽管如此，单任务系统依然在一些基础的嵌入式系统与家电中广泛运用。


### 多任务系统

从另一个角度而言，我们可以通过上下文切换来在单任务系统上模拟多任务：当需要切换进程的时候，将进程信息保存至硬盘，然后将新的进程信息读入并执行。但是这必然带来昂贵的开销。于是，真正的多任务系统就必不可少了。

我们首先做一个假设：进程会使用$p%$的时间来等待IO事务。那么，当内存中有$n$个进程的时候，所有的$n$个进程等待IO的概率为$p^n$，而CPU的利用率为$1 - p^n$。显而易见的，当同时运行的进程越多时，CPU的利用率越高，而当面向IO的进程变多时，CPU的利用率会相对有所降低。

但是，这个假设是建立在所有进程都是相互独立的基础上的，而在现实中，这是不可能的。不过我们仍旧可以用其来进行粗略的估算。

假设一个计算机有1M的内存，操作系统使用了200k，剩下的空间分配给4个200k的进程。那么CPU的利用率就将在60%以下。如果我们增加1M内存，将这些内存分配给5个200k的进程，那么我们的CPU利用率就有了87%。如果我们再增加1M的内存，我们就会得到大于96%的CPU利用率。由此看出，多线程可以很有效地提高资源利用率。

#### 固定分区（同等大小）

固定分区方法将所有用于用户进程的内存分成固定大小的若干个段，这些段拥有固定大小以及固定的位置。

优点：

* 任何进程都可以使用任何足够大的分区
* 开销较小，同时实现简单
* 操作系统只需要追踪被使用的区块与空闲的区块即可

缺点：

* 内存利用率相对较低，内部碎片化程度(internal fragmentation)在分区过大的情况下会很高，分区可能会过大
* 如果程序太大，需要重写内存（折腾程序员）
* 分区过小，追踪、分配的开销会变得很大

同时，固定分区还需要考虑如何将区块分配给任务，如何决定交换等。于是我们需要一些其他的策略来解决这些问题。

#### 固定分区改（不同等大小）

不同等大小分区策略将分区分成大小不同的几个固定区块，这样做的好处是可以增加内存使用率，以及可以更加灵活地分配资源。内部碎片化的程度也因此可以得到控制。相对的，对于不同等大小分区而言，我们需要考虑的是如何将合适的分区分配给相对应的进程。

一种策略是，对于每个分区，我们设置一个私有队列，每次分配进程时，将其安排在空间足够大，且最小的分区:`p.size < m.size && m.isMin`。这种策略，由于每次都能保证进程分配的分区足够且最小，内部碎片度会很有效地减少。但是相对的，内存使用率就会下降（总是将进程分配给最小的段），以及会导致饥饿的发生。

另一种策略则将队列设为全局的，对于每一个进程，分配给当前可用的、装的下的最小队列:`p.size < m.size && m.isAvailable && m.isMin`。
这种策略没有那么容易饥饿(可以将小程序分给大分区)，然而相对的，内部碎片化程度也会相对提高。

另一方面，我们需要注意的是，对内存需求的计算依赖于在程序开始时的估算，而程序的内存需求可能会随着运行而改变。同时，我们也无从预先得知程序运行时内存的分配情况。而进程更可能会被交换(swap)出去，然后被重新载入。那么，我们需要动态的去改变内存分配。

(待续)

