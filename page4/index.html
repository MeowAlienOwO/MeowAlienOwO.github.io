<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Entry &#8211; 喵窝[0]号机</title>
<meta name="description" content="一个伪装成技术博客的吐槽网站。">

<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- other plugins config -->
<!-- mathjax -->
<script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$'], [ '\\(', '\\)']]}});
</script>

<!-- Share.js -->
<link href="/assets/css/share.min.css" rel="stylesheet">
<script type="text/javascript" src="/assets/js/vendor/share.min.js"></script>
<!-- end of plugins -->

<meta http-equiv="content-type" content="text/html; charset=utf-8" />


<!-- Open Graph -->
<!-- <meta property="og:locale" content="en_US"> -->
<meta property="og:locale" content="zh_CN" />
<meta property="og:type" content="article">
<meta property="og:title" content="Entry">
<meta property="og:description" content="一个伪装成技术博客的吐槽网站。">
<meta property="og:url" content="http://MeowAlienOwO.github.io/page4/">
<meta property="og:site_name" content="喵窝[0]号机">





<link rel="canonical" href="http://MeowAlienOwO.github.io/page4/">
<link href="http://MeowAlienOwO.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="喵窝[0]号机 Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://MeowAlienOwO.github.io/assets/css/main.css">
<!-- Webfonts -->
<!-- <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css"> -->
<link href="//fonts.useso.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">
<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://MeowAlienOwO.github.io/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://MeowAlienOwO.github.io/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://MeowAlienOwO.github.io/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://MeowAlienOwO.github.io/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://MeowAlienOwO.github.io/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://MeowAlienOwO.github.io/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://MeowAlienOwO.github.io/images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://MeowAlienOwO.github.io/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://MeowAlienOwO.github.io/images/avatar.png" alt="死鱼眼的喵星人 photo" class="author-photo">
					<h4>死鱼眼的喵星人</h4>
					<p>烈風？いいえ、知らない子ですね。（もぐもぐ</p>

				</li>
				<li><a href="http://MeowAlienOwO.github.io/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:meowalienowo@outlook.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				
				
				
				
				<li>
					<a href="http://github.com/https://github.com/MeowAlienOwO"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://MeowAlienOwO.github.io/posts/">All Posts</a></li>
				<li><a href="http://MeowAlienOwO.github.io/tags/">All Tags</a></li>
				
				<li>
				  <a href="/categories/hello/">
				    hello (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/jekyll/">
				    jekyll (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Computer Science/">
				    Computer Science (12)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Math/">
				    Math (2)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Operating System/">
				    Operating System (3)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/ACG/">
				    ACG (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/空之境界/">
				    空之境界 (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/C++/">
				    C++ (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/Network/">
				    Network (7)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/自言自语/">
				    自言自语 (2)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/日本語/">
				    日本語 (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/japanese/">
				    japanese (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/11区生活/">
				    11区生活 (2)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/生活/">
				    生活 (1)
				  </a>
				</li>
				
				<li>
				  <a href="/categories/linux/">
				    linux (1)
				  </a>
				</li>
				
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  <div class="image-credit">Image source: <a href="http://www.pixiv.net/member_illust.php?mode=medium&illust_id=22958285">ZERO | STAR影法師 [pixiv]</a></div><!-- /.image-credit -->
  
    <div class="entry-image">
      <img src="http://MeowAlienOwO.github.io/images/22958285.jpg" alt="Entry">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>喵窝[0]号机</h1>
      <h2>一个伪装成技术博客的吐槽网站。</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/computer%20science/network/foundation_of_networking/" title="Foundation of Networking"><img src="http://MeowAlienOwO.github.io/images/46203097.jpg" alt="Foundation of Networking"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-13T16:59:52+08:00"><a href="http://MeowAlienOwO.github.io/computer%20science/network/foundation_of_networking/">May 13, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/computer%20science/network/foundation_of_networking/" rel="bookmark" title="Foundation of Networking" itemprop="url">Foundation of Networking</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>考砸了不开心…………………………………………食我酸素鱼雷啦</p>

<p>这个照旧是网络的笔记……John个大坑比……</p>

<h1 id="section">网络基础</h1>

<h2 id="network">何为网络(Network)</h2>

<p>网络是在节点之间传输数据的一种结构。</p>

<ul>
  <li>节点是多种多样的</li>
  <li>节点的数量必须多余两个</li>
</ul>

<p>网络由如下设备组成：</p>

<ul>
  <li>计算设备(computing devices)：主机，终端系统。主要用于运行网络应用。</li>
  <li>传输连接(communication links)：光纤，卫星，广播器等。</li>
  <li>分组交换器(packet switches)：用于传输信息，有路由器(router)与交换器
(switch)两种。</li>
</ul>

<p>互联网：网络的网络，由协议与标准来定义信息的传输。</p>

<h2 id="protocals">互联网协议(protocals)</h2>

<p>互联网协议控制网络信息的发送与接受。协议定义了网络实体之间的信息传输<em>格式</em>，
<em>顺序</em>与对信息传输的<em>行动</em>。</p>

<h2 id="host">主机(host)</h2>

<p>主机以包(packets)的形式传输信息。算法如下：</p>

<ol>
  <li>取得需要传输的信息</li>
  <li>将其截成定长为$L$的小段(chunks)，称之为包(packet)</li>
  <li>将包以某个传输比率(transmission rate)$R$传输至网络</li>
</ol>

<p>传输比率又称连接容量(link capacity)，连接带宽(link bandwidth)，计算公式如下：</p>

<p>$time\ need\ to\ transmit\ L\ bit\ packet\ into\ link = \frac{L(bits)}{R(bits/sec)}$</p>

<h2 id="physical-media">物理媒体(Physical Media)</h2>

<p>比特(bit)：在发送者与接收者之间传输</p>

<p>物理链接(physical link)：连接发送者与接收者的物理材料</p>

<p>导向媒体(guided media)：传输信号的固体媒体，比如铜导线，光纤，同轴电缆</p>

<p>无导向媒体(unguided media)：信号可以自由传播。比如广播。</p>

<h2 id="network-core">网络核心(network core)</h2>

<p>网络核心由一些互相链接的路由器所构成。当主机将应用层的信息转换成包后，将其传输至网络，交给路由器处理，
路由器将收到的包传到下一个路由器。每个包的传输都使用全部的带宽。</p>

<h2 id="section-1">网络结构</h2>

<p>终端系统通过网络服务提供商(Internet Serveice Providers)连接到网络。所有的ISP必须互相之间链接，
这样才能做到路由器之间的通讯。</p>

<p>我们不能将所有的ISP一一相连，这样我们会有$O(n^2)$的连接数目，难于管理。于是出现了ISP的ISP。
但是，不同的高阶ISP又会带来竞争，为了防止竞争造成无法链接的情况，出现了广域网交换点$Internet Exchange Point, IXP$。
同样的，在连接到高阶ISP之前，ISP们之间先组成各种局域网(Regional Network),再通过这些局域网同广域网相连接。同时，如Google, Microsoft之类的内容提供商可以自己组建自己的网络，
使得他们的服务更加快捷地同终端用户相连接。这些网络被称作内容提供网络(content provider network)。</p>

<p>网络的层级如下：</p>

<ol>
  <li>一级网络服务提供商(Tier 1 ISP)与内容提供网络(Content Provider Network)</li>
  <li>广域网交换点(IXP)</li>
  <li>区域ISP</li>
  <li>入口ISP</li>
</ol>

<h2 id="package-switching">封包交换/分组交换(Package switching)</h2>

<p>分组是由一块用户数据和必要的地址和管理信息组成，保证网络能够将数据传递到目标。类似于从邮局发送的包裹上注明的地址一样,只有提供给网络这些信息，网络（邮局）才能把分组（包裹）往正确的地址传送。</p>

<p>分组通过最佳路径(取决于 路由算法)路由到目标。但并不是所有在相同两个主机之间传送的分组（即使是来自同一消息的那些分组）一定要沿着相同的路径传送。</p>

<p>一个数据连接通常传送数据的分组流，它们将不必全部以相同的方式路由过物理网络。目的计算机把收到的所有报文按照适当的顺序重新排列，就能合并恢复出原来的内容。</p>

<p>存储与传输(store-and-forward)：整个包必须在传输到下一个连接之前到达一个路由器。
终端-终端延迟在理想状况下为$2L / R$。</p>

<h3 id="section-2">队列与丢包</h3>

<p>如果路由器的包到达速率超过了其传输速率，那么会发生两种情况：</p>

<ul>
  <li>包被存储在队列中等待，或者</li>
  <li>当队列存储容量满了以后，包会丢失(dropped)</li>
</ul>

<h3 id="section-3">两个关键的的网络核心功能</h3>

<p>路由(routing):决定包的源地址路由器</p>

<p>传输(forwarding):将包从路由的输入转换到正确的输出</p>

<h3 id="circuit-switchingaohu">另一种核心：电路交换(circuit switchingaohu)</h3>

<p>根据
<a href="http://zh.wikipedia.org/wiki/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2" title="电路交换">维基百科</a>的解释，电路交换是在两个通信终端之间建立起一个连接，
双方通过这条通道进行信息的交换。这个连接一直保留到双方的通信结束，在通
信结束之前，连接将始终被占用。这种方式常用在传统的电话网络中。</p>

<h4 id="fdmtdm">电路交换的频分多路复用(FDM)与时分多路复用(TDM)</h4>

<p>频分多路复用(Frequency-division multiplexing)指的是将不同的信息编码至
不同的频率段，从而使得同时可以有多个用户进行通信的技术。频分多路复用在
现代的通信中应用相对较少</p>

<p>时分多路复用(Time-Division Multiplexing)指的是将时间域分成固定的小段，每个小段分配给某个固定的用户
进行通信的技术。典型应用有GSM。</p>

<h3 id="vs-">封包交换 vs 电路交换</h3>

<p>电路交换的最大缺陷是能够服务的用户数量有限，而封包交换往往可以服务更广的用户。</p>

<p>封包交换的优势在于可以共享通信资源以及更加简单(不需要初始化连接)。
但是，封包交换同样存在着延迟与丢包的问题，在需要可信的数据传输的时候，这种方式并不是最好选择。</p>

<h3 id="section-4">丢包与延迟的来源</h3>

<h4 id="section-5">丢包</h4>

<p>路由器使用队列来储存包的请求，当接受速率大于传输速率时，包会被储存进路由器的队列中。当队列容量满时，这时候便无法接受数据包，造成丢包。</p>

<h4 id="section-6">延迟</h4>

<p>对于单路由节点而言，延迟的来源有四个：</p>

<ul>
  <li>节点处理过程(nodal processing)：包含比特错误校验(check bit errors)，确定输出连接等，通常小于毫秒量级</li>
  <li>队列延迟(queueing delay)：等待输出连接的传输时间，由当前连接的拥挤程度而决定</li>
  <li>转换延迟(transmission delay)：将数据输入传输连接的时间，计算方式为$d_{trans} = L / R$,$L$表示包长度，$R$表示带宽</li>
  <li>传输延迟(propagation delay):数据在连接媒体之间传输的时间，计算方式为$d_{prop} = d / s$，$d$表示物理连接的长度，$s$表示传输速度的中位数</li>
</ul>

<p>计算延迟的公式为：</p>

<p>$d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop}$</p>

<h2 id="section-7">层级</h2>

<h3 id="section-8">网络协议层级栈</h3>

<ol>
  <li>应用层(application)：支持网络应用，如FTP, SMTP, HTTP等</li>
  <li>传输层(transport)：进程-进程(process-process)之间的数据传输，TCP，UDP</li>
  <li>网络层(network)：路由相关，如IP，路由协议</li>
  <li>连接层(link)：在相邻网络元素之间的数据传输，如以太网(Ethernet),802.111协议，PPP等</li>
  <li>物理层(physical)：二进制数据</li>
</ol>

<h3 id="isoosi">ISO/OSI七层模型</h3>

<p>在网络协议层级的应用层与传输层之间加入了表示层与会话层。</p>

<ol>
  <li>表示层(presentation)：允许应用解释数据的意义，比如加密，压缩，机器特定的约定，等</li>
  <li>会话层(session)：同步，校验点(checkpoint)，从数据交换中恢复等等</li>
</ol>

<p>一般而言，这两个层级被认为并非绝对必要，且属于应用层的实现。</p>

 -->
    
        <p>考砸了不开心…………………………………………食我酸素鱼雷啦</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/computer%20science/math/machine_and_their_language(2)/" title="MAL-下推自动机与上下文无关语言"><img src="http://MeowAlienOwO.github.io/images/31958311.png" alt="MAL-下推自动机与上下文无关语言"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-05-03T14:49:02+08:00"><a href="http://MeowAlienOwO.github.io/computer%20science/math/machine_and_their_language(2)/">May 03, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/computer%20science/math/machine_and_their_language(2)/" rel="bookmark" title="MAL-下推自动机与上下文无关语言" itemprop="url">MAL-下推自动机与上下文无关语言</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>考前复习+Course work复习, 下推自动机与上下文无关语言部分……土狼：people die if they are killed。</p>

<p>MD还要躺着……戴了护裆都能中招真是……</p>

<embed height="452" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="http://share.acg.tv/flash.swf" flashvars="aid=382643&amp;page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" />

<h1 id="section">上下文无关语言</h1>

<h2 id="context-free-grammar">上下文无关文法(Context-Free Grammar)</h2>

<p>上下文无关文法由一个四元组$G=(V, \Sigma, S, P)$来描述。其中：</p>

<ul>
  <li>$V$ 是变量集合，或者说非停止符号集</li>
  <li>$\Sigma$ 是停止符号集</li>
  <li>$S$ 是起始变量</li>
  <li>$P$ 是语法规则集(rule/productions)，$P$中的元素通常是如下的形式：$A \to
\alpha, A \in V, \alpha \in (V \cup \Sigma)$</li>
  <li>$S \in V$, $V$ 与 $\Sigma$无交集。$V$, $S$, $P$都是有限的。</li>
</ul>

<p>我们使用如下的符号来表示一些推导规则：</p>

<ul>
  <li>$\to$ 表示在语法中的一个生成规则(production), $\Rightarrow$表示根据语法
规则的一步推导(derivation)</li>
  <li>$\alpha \Rightarrow^n \beta$ 表示$n$步推导，$\alpha \Rightarrow^*
\beta$ 表示0或者多步推导。</li>
  <li>$\Rightarrow_G$ 表示根据语法$G$的推导。</li>
</ul>

<p>$\alpha \Rightarrow \beta$ 表示存在字符串$\alpha_1, \alpha_2$, $\gamma \in (V
\cup \Sigma)^*$, 以及生成规则$A \to \gamma \in P$, 使得$\alpha = \alpha_1 A
\alpha_2$, $\beta = \alpha_1 \gamma \alpha_2$</p>

<p>当如上的推导规则可以对于任意可能的$\alpha_1,\alpha_2$都成立时，我们认为该规则是
上下文无关的(context-free)</p>

<h2 id="context-free-language">上下文无关语言(Context-Free Language)</h2>

<p>假设存在一个上下文无关文法(CFG)$G=(V, \Sigma, S, P)$, 由$G$生成的语言
为：
$ L(G) = \lbrace \chi \in \Sigma^* | S \Rightarrow_G^* \chi \rbrace $</p>

<p>当存在一个语言$L$,使得$L = L(G)$, 我们可以说这个语言是上下文无关语言(Context-Free Language)。</p>

<h2 id="kleene">联合，连接与Kleene星号运算</h2>
<p>如果$L_1$, $L_2$都是定义在$\Sigma$上的上下文无关语言，那么$L_1 \cup
L_2, L_1 L_2, L_1^*$都是上下文无关语言。</p>

<p>令$G_1, G_2$分别表示$L_1, L_2$的语法，假设他们之间没有公共变量。$S_1,
S_2$分别是起始变量。</p>

<p>令$S_u, S_c, S_k$分别表示联合，连接与Kleene星号的起始变量，$G_u, G_c,
G_k$表示对应的语法，我们可以创造如下规则使前述定理成立：</p>

<ul>
  <li>对于$G_u$, 向$G_1, G_2$添加规则$S_u \to S_1 | S_2$</li>
  <li>对于$G_c$, 向$G_1, G_2$添加规则$S_c \to S_1 S_2$</li>
  <li>对于$G_k$, 向$G_1$添加规则$S_k \to \Lambda | S_k S_1$</li>
</ul>

<h2 id="derivation-tree">派生树(Derivation Tree)与歧义</h2>

<p>派生树用于表示CFG生成字符串的一般步骤。构建派生树的方法如下：</p>

<ul>
  <li>跟节点用于表示起始变量S</li>
  <li>任何内节点(interior node)与它的子节点表示一个通过推导规则$A \to \alpha$派生产物
该节点表示变量A, 而其子节点，从左至右表示在字符串$\alpha$下的符号</li>
  <li>任何叶结点表示一个符号或者空串</li>
  <li>最终派生的字符串从左到右读入，排除任何的空串</li>
  <li>一个派生方法只能得到一个派生树，而一个派生树可以表示不止一种派生方法</li>
</ul>

<p>在实际应用中，我们通常使用左派生(leftmost derivation)，即对于每一步推
导，我们永远对当前最左边的变量使用派生规则。</p>

<p>我们有如下定理：
如果G是CFG，那么对于所有的$x \in L(G)$, 我们有如下三个表述等价：</p>

<ul>
  <li>$x$ 有多于一个的派生树</li>
  <li>$x$ 有多于一个的左派生树</li>
  <li>$x$ 有多于一个的右派生树</li>
</ul>

<p>我们认为对于一个是CFG的G是有歧义的，当该G存在至少一个$x \in L(G)$, $x$
有多于一个的派生树，或者根据如上定理，有多于一个的左派生树。</p>

<p>典型例子：</p>

<blockquote>
  <p>if (e1) if (e2) f(); else g();</p>
</blockquote>

<p>我们可以通过引入新变量来消除歧义。</p>

<h2 id="simplified-formsnormal-forms">简式(Simplified Forms)与范式(Normal Forms)</h2>

<h2 id="section-1">上下文无关语言的泵引理</h2>

<p>CFL同样有泵引理的应用。令$L$为CFL，那么必然存在一个正整数$n$,使得对于任意的$u
\in L, | u | \geq n$, $u$可以被写成$u=vwxyz$, 而且满足：</p>

<ul>
  <li>$| wy | &gt; 0$</li>
  <li>$| wxy | \leq n$</li>
  <li>$\forall m \geq 0, vw^mxy^mz \in L$</li>
</ul>

<p>（证明待补充）</p>

<h2 id="section-2">泵引理的应用</h2>

<p>我们以$L = \lbrace a^nb^nc^n | n \geq 0 \rbrace$作为例子说明泵引理在证明某个语
言非上下文无关中的应用。</p>

<p>令$u$是一个形如$a^nb^nc^n$的字符串且$| u | \geq n$</p>

<p>我们有$u=vwxyz$满足泵引理之条件。$| wy | &gt; 0$说明字符串$wy$至少有一个符号。$|
wxy | \leq n$说明$wxy$至多含有两个不同的符号。假设$\sigma_1$是一个出现在$wy$中
的符号，$\sigma_2$是不在$wy$中的符号。那么字符串$vw^0xy^0z$同样可以保持$u$的特性，
但是显然$\sigma_1$的数目小于$n$,而$\sigma_2$的数目等于$n$，这与泵引理的第3条特性
矛盾。</p>

 -->
    
        <p>考前复习+Course work复习, 下推自动机与上下文无关语言部分……土狼：people die if they are killed。</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/computer%20science/operating%20system/operating_system-_memory_management/" title="操作系统笔记二：内存管理"><img src="http://MeowAlienOwO.github.io/images/27167056.jpg" alt="操作系统笔记二：内存管理"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-03-30T19:10:06+08:00"><a href="http://MeowAlienOwO.github.io/computer%20science/operating%20system/operating_system-_memory_management/">March 30, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/computer%20science/operating%20system/operating_system-_memory_management/" rel="bookmark" title="操作系统笔记二：内存管理" itemprop="url">操作系统笔记二：内存管理</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>操作系统笔记之二，内存管理。每一次上操作系统跟MAL都是智商上的一种煎熬啊……跟上一篇同样，这也是一些翻译ppt的内容，充作笔记。</p>

<h1 id="section">基础知识</h1>
<h2 id="section-1">硬件存储器层级与操作系统</h2>

<p>现代的算机通常有如下几种存储层级，由速度快慢排列如下：</p>

<ol>
  <li>寄存器，1/2/3级缓存</li>
  <li>主内存</li>
  <li>硬盘</li>
</ol>

<p>更高级的存储器更快，但是代价更加昂贵以及更加容易被改变，低级的则相反。
内存可以被认为是一个线性的字节/单词的数组，而操作系统负责提供内存的抽
象。</p>

<p>操作系统负责：</p>

<ol>
  <li>根据进程的请求分配/收回内存</li>
  <li>追踪内存的使用情况</li>
  <li>“透明地”(Transparently)在内存与硬盘之间移动信息</li>
  <li>在进程之间分配内存，模拟”无限大”的内存空间</li>
  <li>多任务的情况下，负责控制权限分配</li>
</ol>

<h2 id="section-2">内存管理模型</h2>

<p>内存管理模型有两种：连续模型与非连续模型。</p>

<p>连续模型将所有的内存看作单个内存块，而非连续模型将内存分为若干内存块，
或者称之为段(segments)。这些段可以在物理内存中的任何位置，而不需要一定与彼此相邻。</p>

<p>至于内存的分区方面，对于单任务系统而言，只需要一个分区即可。而对于多任务系统而言，分区有多种方案。多任务系统可以是动态分区的，也可以是固定分区的。对于固定分区而言，有相等分区与不等分区两种。</p>

<h3 id="section-3">单任务系统</h3>

<p>单任务系统每次只允许一个用户进程在内存中被执行。内存的一部分被操作系统使用，而另外一部分被用户系统所使用(“MS-DOS”方式)。被操作系统所使用的部分一般而言是固定大小的，通常可以直接使用物理内存。</p>

<table border="1">
<tr>
<th>...</th>
<th>用户进程</th>
<th>...</th>
<th>操作系统内核</th>
</tr>
</table>

<p>这种方式没有保护用户进程的必要，因为同一时间只有一个程序在运行。由于一个进程通常使用了所有的内存空间，同一进程通常被分配在同样的内存地址。当然，程序员可以用覆盖的方法来使用更多的空间，但是这种方法看起来更容易造成麻烦。</p>

<p>对于单任务系统而言，它的缺点是显而易见的：</p>
<ol>
  <li>由于用户进程可以直接使用物理内存，它有可能会对操作系统的内存进行读写。</li>
  <li>如果我们将操作系统自身看作一个进程的话，实际上有两个进程同时运行(ppt原话翻译，我的理解是这可能是因为虽然是两个进程，但是由于单任务的特性，一次只能运行一个进程，这也意味着操作系统进程在用户进程被激活时是处于suspend状态，结合前面的直接读取权限，很可能用户进程对操作系统内存的读写是没有保护的。另一个问题可能也是进程排程的问题，操作系统进程无法跟用户进程协同。)</li>
  <li>对硬件资源的利用率低(比如说IO)</li>
  <li>无法适应需要多任务的场景</li>
</ol>

<p>尽管如此，单任务系统依然在一些基础的嵌入式系统与家电中广泛运用。</p>

<h3 id="section-4">多任务系统</h3>

<p>从另一个角度而言，我们可以通过上下文切换来在单任务系统上模拟多任务：当需要切换进程的时候，将进程信息保存至硬盘，然后将新的进程信息读入并执行。但是这必然带来昂贵的开销。于是，真正的多任务系统就必不可少了。</p>

<p>我们首先做一个假设：进程会使用$p%$的时间来等待IO事务。那么，当内存中有$n$个进程的时候，所有的$n$个进程等待IO的概率为$p^n$，而CPU的利用率为$1 - p^n$。显而易见的，当同时运行的进程越多时，CPU的利用率越高，而当面向IO的进程变多时，CPU的利用率会相对有所降低。</p>

<p>但是，这个假设是建立在所有进程都是相互独立的基础上的，而在现实中，这是不可能的。不过我们仍旧可以用其来进行粗略的估算。</p>

<p>假设一个计算机有1M的内存，操作系统使用了200k，剩下的空间分配给4个200k的进程。那么CPU的利用率就将在60%以下。如果我们增加1M内存，将这些内存分配给5个200k的进程，那么我们的CPU利用率就有了87%。如果我们再增加1M的内存，我们就会得到大于96%的CPU利用率。由此看出，多线程可以很有效地提高资源利用率。</p>

<h4 id="section-5">固定分区（同等大小）</h4>

<p>固定分区方法将所有用于用户进程的内存分成固定大小的若干个段，这些段拥有固定大小以及固定的位置。</p>

<p>优点：</p>

<ul>
  <li>任何进程都可以使用任何足够大的分区</li>
  <li>开销较小，同时实现简单</li>
  <li>操作系统只需要追踪被使用的区块与空闲的区块即可</li>
</ul>

<p>缺点：</p>

<ul>
  <li>内存利用率相对较低，内部碎片化程度(internal fragmentation)在分区过大的情况下会很高，分区可能会过大</li>
  <li>如果程序太大，需要重写内存（折腾程序员）</li>
  <li>分区过小，追踪、分配的开销会变得很大</li>
</ul>

<p>同时，固定分区还需要考虑如何将区块分配给任务，如何决定交换等。于是我们需要一些其他的策略来解决这些问题。</p>

<h4 id="section-6">固定分区改（不同等大小）</h4>

<p>不同等大小分区策略将分区分成大小不同的几个固定区块，这样做的好处是可以增加内存使用率，以及可以更加灵活地分配资源。内部碎片化的程度也因此可以得到控制。相对的，对于不同等大小分区而言，我们需要考虑的是如何将合适的分区分配给相对应的进程。</p>

<p>一种策略是，对于每个分区，我们设置一个私有队列，每次分配进程时，将其安排在空间足够大，且最小的分区:<code>p.size &lt; m.size &amp;&amp; m.isMin</code>。这种策略，由于每次都能保证进程分配的分区足够且最小，内部碎片度会很有效地减少。但是相对的，内存使用率就会下降（总是将进程分配给最小的段），以及会导致饥饿的发生。</p>

<p>另一种策略则将队列设为全局的，对于每一个进程，分配给当前可用的、装的下的最小队列:<code>p.size &lt; m.size &amp;&amp; m.isAvailable &amp;&amp; m.isMin</code>。
这种策略没有那么容易饥饿(可以将小程序分给大分区)，然而相对的，内部碎片化程度也会相对提高。</p>

<p>另一方面，我们需要注意的是，对内存需求的计算依赖于在程序开始时的估算，而程序的内存需求可能会随着运行而改变。同时，我们也无从预先得知程序运行时内存的分配情况。而进程更可能会被交换(swap)出去，然后被重新载入。那么，我们需要动态的去改变内存分配。</p>

<h1 id="section-7">地址管理</h1>

<h2 id="section-8">基础知识</h2>

<ul>
  <li>
    <p>相对分配(relocation)：操作系统无法在程序运行之前预先知道这个程序的分区与地址。这就意味着操作系统不能简单地静态地分配绝对地址，而相对的，地址必须根据运行时的情况进行相对分配。</p>
  </li>
  <li>
    <p>保护：当有复数的程序在内存中运行时，必须进行保护。</p>
  </li>
  <li>
    <p>逻辑地址(logical address)是进程所知道的内存形式。其独立于当前的物理内存，比如同程序的开始地址相对。</p>
  </li>
  <li>
    <p>物理地址(physical address)表示在主内存中的实际地址。逻辑地址空间必须以某种方式映射到物理地址空间上。</p>
  </li>
</ul>

<h2 id="section-9">管理方法</h2>

<ul>
  <li>编译时静态相对分配内存：一个进程每次都会被放在相同的地址</li>
  <li>在载入时动态相对分配内存：逻辑地址是相对的，每次载入的时候通过计算偏移量来分配内存块。这会使载入变慢。</li>
  <li>运行时动态分配内存</li>
</ul>

<p>在CPU中，有两个特殊的寄存器用来存储基准地址(base address)与极限(limit)。基准寄存器用于储存分区的开始地址(start address)，极限寄存器用来存储分区的极限</p>

<p>运行时，基准寄存器的地址加上逻辑地址就可以得出物理地址，得出的结果会同极限寄存器中储存的值进行比较来判断是否有效。这种方式需要硬件支持。</p>

<p>固定分区会导致内部碎片(internal fragmentation)：与进程需求完全一致的分区可能不存在，那么空间就有可能没有被完全使用。于此相反，动态分区可以动态地改变内存的开始地址与极限地址。同时，一个进程通常会被分配一块与其内存需求完全相符的连续地址，这就很有效的减少了内存的碎片化程度。</p>

<h2 id="swapping">交换(swapping)</h2>

<p>交换可以将进程的一部分信息保存在硬盘里，然后在主内存跟硬盘之间交换信息。</p>

<p>我们需要使用交换的理由如下：</p>

<ul>
  <li>我们可能有多余分区数的进程数量（假设我们使用固定分区方法）</li>
  <li>总内存的需求大于空余内存需求</li>
  <li>一些进程只是偶尔运行</li>
  <li>进程的内存需求可能会改变</li>
</ul>

<p>外部碎片：
进程的交换也可能会导致内存的碎片化。将一个进程交换出去时，内存中会留下来一个“洞”，当另外的程序使用这个”洞”时，可能并没有使用整个空间，这样一来就会导致一些小小的，没有使用过的内存碎片。同时，一个新进程可能对于这个空间而言过大，那么就有可能导致这个空间自身成为一个碎片。另一方面，对于内存压缩来说，寻找这些碎片的代价也是非常高昂的，同时也需要动态的相对内存分配。</p>

<p>现在，内存管理的问题是：</p>

<ul>
  <li>如何快速地将可用的内存分配给进程</li>
  <li>如何追踪内存的使用-&gt;链表/表</li>
</ul>

<h2 id="section-10">动态分区</h2>

<p>我们需要一个更加复杂的内存分配数据结构来处理可变的使用与空闲的分区数量。</p>

<h3 id="section-11">链表</h3>
<p>链表是一个可以实现如此的数据结构。示意图如下：</p>

<table border="1">
<tr><th>入口指针</th></tr>

<tr>
<th>是否空闲？</th>
<th>开始地址</th>
<th>大小</th>
<th>next指针</th>
</tr>
<tr>...</tr>
<tr>
<th>是否空闲？</th>
<th>开始地址</th>
<th>大小</th>
<th>next指针</th>
</tr>
<tr>...</tr>
<tr>
<th>是否空闲？</th>
<th>开始地址</th>
<th>大小</th>
<th>next指针(结束)</th>
</tr>
</table>

<h4 id="first-fit-algorithm">第一匹配算法(first fit algorithm)</h4>

<p>在初始化的时候，整个内存被认为是一整块，标记为空闲(free)。</p>

<p>当请求内存时，遍历整个链表，直到找到一个足够大的空闲空间。如果这个空间恰好需求相等时，将这块空间标记为使用(used)。如果这块空间比需求的空间大，将接下来的空间切分成另一块链表的节点，标记为空闲。当一块内存被释放时，该内存被设定为空闲。</p>

<h4 id="second-fit-algorithm">匹配算法改-第二匹配算法(second fit algorithm)</h4>

<p>第一匹配算法的近代化改修型。</p>

<p>第一匹配算法在第一次请求内存时开始进行扫描，而第二匹配算法保存一个当前搜索位置的指针。第二次搜索时，从上一次扫描的结尾开始。这种算法可以保证所有的内存块都被扫描。但是第二匹配算法在实验中表现出来的效率比第一匹配差。</p>

<h4 id="best-fit-algorithm">匹配算法改二-最佳匹配算法(best fit algorithm)</h4>

<p>第一匹配只匹配第一个<strong>足够大</strong>的空间，假设在之后的链表中存在一个恰好符合的空间，那么就会导致内存碎片的出现。</p>

<p>最佳匹配算法总是选择一个大小最适合的区块进行分配。然而，由于搜索的存在，必然会导致整个算法的速度降低。同时，令人惊讶的是，这种算法也会导致更高的内存浪费——每个“最合适”的区块万一不是恰好，就会被分割出一块最小的空间。</p>

<h4 id="worst-fit-algorithm">配算法改三-最差匹配算法(worst fit algorithm)</h4>

<p>为了防止最佳匹配算法所导致的大量碎片内存，最差匹配算法每次都会选择一块最大的内存，这样子切分下来的内存就通常会有更高的可用性。</p>

<p>然而在实际应用中似乎并没有什么卵用。</p>

<h4 id="section-12">快速匹配与其他算法</h4>

<p>快速匹配大致是保存一份链表，里面分别保存固定大小的内存块，
比如4byte,8byte……对于一个内存请求而言，寻找最接近的一块内存分配/
如果是奇数大小的内存，或者寻找最近，或者在一个独立的表中处理内存。</p>

<h3 id="bitmap">点阵(bitmap)</h3>

<p>作为链表的一种补充，点阵也是一种有效的数据结构。</p>

<p>这些内存方法同样还有一些其它问题，比如进程运行时会请求更多内存等，
我们需要动态的内存分配方法。</p>

<h1 id="paging">分页(Paging)</h1>

<p>分页是基于固定分区(fixed partitioning)与代码重分配(code re-location)来的非连续内存管理方案。</p>

<ul>
  <li>内存被分成很小的块(4kb左右)，每个进程被分配不止一个块</li>
  <li>内存块不必物理上连续，但是进程仍然认为他们是连续的</li>
</ul>

<p>同如上介绍的连续内存管理方案相比，分页方法有如下好处：</p>

<ul>
  <li>内部碎片只会发生在最后的内存块</li>
  <li>没有外部碎片，物理上所有的内存块都以栈的形式一个连着一个存储</li>
</ul>

<h2 id="section-13">定义</h2>

<p>一个页(page)是一个在逻辑地址空间(logical address space)上的连续小内存块。</p>

<p>相对的，一个帧(frame)是一个在物理内存(physical memory)上连续小内存块。</p>

<p>通常页与帧具有相同的大小，为2的指数，大致在512byte与1Gb之间。</p>

<h2 id="relocation">重分配(relocation)</h2>

<p>逻辑地址需要被转换成物理地址，对于每一个页，我们需要一个基寄存器(base register)
来存储相对的帧所在的地址位置。显而易见的我们需要复数的基寄存器，这些寄存器被存储在分页表(page table)中。
分页被视为一个将页编号与帧编号一一对应的函数映射，我们有：</p>

<p>$frameNum = f(pageNum)$</p>

<p>页面数字被用作分页表的索引(index)，存储其相对应的帧在内存中的顺序。</p>

<p>每一个进程都有他们自己的分页表，存储他们自己的基寄存器。</p>

<p>操作系统维护一个空闲帧的列表。</p>

<h2 id="section-14">地址转换的实现</h2>

<p>一个逻辑地址是想对于程序的开始而言的，其包含两个部分：</p>

<ul>
  <li>左边n个比特位存储页的序数</li>
  <li>右边m个比特位存储在页中的偏移量(offset)</li>
</ul>

<p>物理地址拥有与逻辑地址相同的格式，他们之间的转换由分页表实现。</p>

<p>地址转换的步骤：</p>

<ol>
  <li>将页序数从逻辑表中取出</li>
  <li>使用页序数在分页表中寻找帧序数</li>
  <li>将偏移量加到帧的基寄存器上</li>
</ol>

<p>地址转换的硬件实现：</p>

<ol>
  <li>CPU的内存管理单元(memory management unit)用于拦截(intercept)(?)逻辑地址</li>
  <li>使用分页表进行地址转换</li>
  <li>得出的物理地址被放入内存总线(memory bus)</li>
</ol>

<h1 id="virtual-memory">虚拟内存(virtual memory)</h1>

<p>分页依然存在一些问题：</p>

<ul>
  <li>代码的执行与数据结构被分解成很小的子集</li>
  <li>在同一时刻，不是所有的页面都需要被读入内存，只有在需求时才读入</li>
</ul>

<p>所以我们引入虚拟内存方法。虚拟内存指只有在需要的时候将对应的程序信息读入内存，
但是对于程序而言，它所”看”到的仍然是一整块可用的内存。</p>

<p>虚拟内存允许逻辑地址空间大于物理内存空间。理论上，64位机器可以支持$2^64$个逻辑地址。
这意味着机器有更大的空间容纳更多的进程，而更多的进程可以提高CPU使用率。</p>

<h2 id="page-fault">页面错误(page fault)</h2>

<p>页面错误是指在运行过程中，发现所需要的地址并不在内存中而引发的一个异常，通常作为虚拟内存的交换机制的触发器。
页面错误会导致一个中断(interrupt)，进程进入阻塞状态(blocked state)。操作系统触发一个IO操作，
将不存在的页面读入内存，这里可能会发生上下文切换。IO操作处理完了以后，发出一个中断信号表明IO操作完成，
进程进入准备状态。常驻集(resident set)用于表示被读入主内存的页面。</p>

<p>处理页面错误的流程：</p>

<ol>
  <li>操作系统陷阱(trap operating system)
    <ul>
      <li>储存当前的寄存器与进程状态</li>
      <li>分析中断，例如页面错误</li>
      <li>合法化页面引用，确定页位置</li>
      <li>处理IO事务：队列，寻找，延迟，转换</li>
    </ul>
  </li>
  <li>(可能的)上下文切换</li>
  <li>中端等待IO完成
    <ul>
      <li>存储进程状态/寄存器</li>
      <li>分析磁盘终端</li>
      <li>更新分页表与在内存中的页面</li>
      <li>等待原先的进程被排入时间表</li>
    </ul>
  </li>
  <li>上下文切换至原先的进程</li>
</ol>

<h2 id="section-15">分页表的内容</h2>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>other</td>
        <td>caching</td>
        <td>referenced</td>
        <td>modified</td>
        <td>protection</td>
        <td>present/absent</td>
        <td>frame num</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<ul>
  <li>”出席/缺席“位(present/absent bit)用于指示是否在内存中</li>
  <li>“更改”位(modified bit)用于表示页面是否经过更改</li>
  <li>“引用”位(referenced bit)用于表明页面是否在使用</li>
  <li>“保护”域(protection bits)用于表明页面的读写执行权限</li>
  <li>“缓存”位(caching bit)用于表明页面是否写入设备寄存器</li>
</ul>

<h2 id="section-16">处理大型分页表</h2>

<p>在16bit机器上，地址空间为2^16，假设一个页面为2^10bit,剩下6bit用于标记页面序数，总共可以维护64个页面表。
32bit机器上，一个页面为4kb(2^12)，有20位可以标记页面，总共维护的数量大约为100000。64bit机器拥有更加大量的页面数量。
如何处理更大的页面数量，是一个问题。</p>

<p>首先，对如此大的分页表，将其存储在寄存器不是一个好选择。我们选择将其放在主内存中(虚拟内存)。</p>

<ul>
  <li>多级分页表(multi-level page table)</li>
  <li>逆分页表(inverted page table)</li>
</ul>

<p>另一个需要考虑的是处理时间，由于每次分页都需要进行转换，速度必须足够快。</p>

<h3 id="section-17">多级分页表</h3>

<p>这是一个简单的实现方式。考虑一个32位机器，对于每一个地址，我们使用10bit的PT1域，10bit PT2域，12bit的偏移量。令页面大小4k，总共2^20个页面。</p>

<p>多级分页表不将所有的页面全部放在内存中，在如上例子中，我们将分页表分为两个层级，每个分页表都有2^10项，第一层分页表只有一个，对应1024个子分页表，在地址上我们使用PT1域。第二层分页表有1024个，每个对应1024个页面，使用PT2域。得到目标地址的方法：</p>

<ol>
  <li>PT1+顶层表指针得到第二层表指针</li>
  <li>第二层表指针+PT2得到帧序号</li>
  <li>帧序号+偏移量得到目标物理地址</li>
</ol>

<p>对于任意一个地址，我们只需要保存第一层与相对的第二层表即可。
处理时间：
$L * T + C$,</p>

<p>L 表示层级数， T表示处理每个表的时间，C表示剩余的常数项。</p>

<p>当表已经在内存中时，寻找时间会变成原来的3倍(加上处理两个表)</p>

<h3 id="tlb">TLB</h3>

<p>我们使用传输后备缓冲器TLB(Translation Look aside Buffer)来对一些经常使用的页面与表的入口进行缓存。
页面表的搜索与TLB中的搜索是平行的。
TLB同其他的缓存没有什么不同。</p>

<p>搜索算法：</p>

<ol>
  <li>同时搜索TLB与分页表</li>
  <li>如果TLB中搜索到，直接得出帧序号+偏移量(TLB Hit)</li>
  <li>如果不在TLB中，搜索分页表得到帧序号(TLB Miss)</li>
</ol>

<p>假设我们需要20ns在TLB中寻找，内存处理时间100ns</p>

<p>对于单层表而言,TLB Hit时间为20 + 100ns(TLB搜索时间+内存)
TLB Miss时间为20 + 100 + 100ns(TLB搜索时间+分页表搜索时间+内存)</p>

<h3 id="section-18">逆分页表</h3>

<p>一个“正”分页表的大小同虚拟空间大小对应，而一个“逆”分页表同主内存的大小对应。
逆分页表通过哈希函数来得到页面数字，而且使用帧序号作为索引。</p>

<h3 id="thrashing">击打(Thrashing)</h3>

<p>假设所有的可以使用的表都在被活跃地使用，读入一个新的内存表时，这个表需要马上被交换出来，然后很快被读回去。</p>

<p>击打发生在某块内存被交换出去，然后马上被读入的时候，使得CPU使用率下降
CPU使用率下降会导致多任务程度上升，而多任务程度上升会进一步增加IO事务，减低CPU使用率。</p>

<p>击打的原因包括：</p>

<ul>
  <li>过高的多任务程度</li>
  <li>单个进程被分配的页面太少</li>
</ul>

<p>我们可以使用减低多任务率以及使用一个更好的页面替换策略来防止击打的发生。</p>

<h1 id="page-replacing-algorithms">页面替换算法(Page-replacing Algorithms)</h1>

<h2 id="demand-paging">页面请求(demand paging)</h2>

<p>令ma, p, pft表示内存处理时间(memory access time)，页面错误率(page fault rate)，页面错误处理时间(page fault time)，
总处理时间(access time)为:</p>

<p>$(1 - p) * ma + pft * p$</p>

<p>一般而言处理时间与页面错误率成正比。</p>

<p>虚拟内存依赖于共用页面组的位置。进程从一个位置移向另一个，如果所有需求的页面都在内存中，就不会出现页面错误。</p>

<p>页面请求从内存中没有页面开始，第一个指令会马上导致页面错误。之后，页面错误数量会增加，但是最终会维持在一个稳定的水平。</p>

<h2 id="pre-paging">页面预载入(Pre-paging)</h2>

<p>当进程开始后，所有被预计所要使用的页面(工作集，working set)会一次性被读入内存。这将减少页面错误数量，而且减少转换所需时间。</p>

<p>预载入在页面错误产生之前发生，经常被用在进程被交换的时候。</p>

<h2 id="section-19">页面替换算法</h2>

<p>当一个新的页面载入时，操作系统需要选择一个页面来移除。这个选择是由页面替换算法所决定的。
这个算法需要考虑时间成本以及防止击打。</p>

<h3 id="optimal-pae-replacement">最优页面替换(optimal pae replacement)</h3>

<p>每一个页面都有一个接下来需要执行的操作/接下来再被调用所需要的时间长度的列表，将最长时间不用的页面交换出去。
这个算法在实现上是不可能的。但是这可以被提前执行分析所应用，也可以提供一个页面错误数量的下界。</p>

<h3 id="not-recently-used-nru">最近未使用(not recently used, NRU)</h3>

<p>NRU使用引用比特位与更改比特位来寻找下一个页面。在开始的时候，所有的引用比特位都设置未0，并且周期性地重置为0。
当页面错误发生时，操作系统检查分页表，根据这两个比特位的取值，分成四种页面类型(page class):</p>

<ol>
  <li>无引用，无更改</li>
  <li>无引用，有更改</li>
  <li>有引用，无更改</li>
  <li>有引用，有更改</li>
</ol>

<p>NRU算法从编号低的类型开始，选取第一个非空类型中的一个任意页面移除。</p>

<p>NRU的性能尚可，对于理解与实现而言也相对简单。</p>

<h3 id="section-20">先进先出</h3>

<p>先进先出维护一个链表，新的页面会加入链表的末端。
每次交换的时候交换链表头的元素。这是一个简单的实现，但是会有比较糟糕的性能：它不知道哪些页面被经常使用。</p>

<p>有改进型第二选择FIFO(second chance FIFO)</p>

<p>如果一个页面在链表的前面且引用位为0，则将其交换；如果引用位非0，将这个页面放在链表的最后，重置其引用位。</p>

<p>这个算法依然比较简单，但是开销非常大。同时，当所有的页面被引用时，它会退化为平凡的FIFO算法</p>

<h3 id="clock-replacement-algorithm">时钟替换算法(clock replacement algorithm)</h3>

<p>将第二选择FIFO的链表首尾相连就成为时钟替换算法。我们保存一个指针指向最老的页面。这个算法中，指针只能想一个方向移动。</p>

<p>这个算法效率更高，但是当链表很长的时候表现依然糟糕。</p>

<h3 id="least-recently-used-lru">最近少使用(least recently used, LRU)</h3>

<p>最近少使用算法移除一个距今最长时间不用的页面。操作系统必须追踪页面上一次被使用距今的时间，每个分页表入口有一块区域来存储计数器。
这个实现的开销也不小，因为我们需要维护一个根据时间排序的页面列表(或者搜索)。</p>

<p>这个算法可以在硬件层面加入一个计时器实现。</p>

<h2 id="paging-daemons">页面守护进程(Paging daemons)</h2>

<p>实际上，保存一些空闲的页面来应对未来可能发生的页面错误更加经济有效。许多系统现在有一个后台的页面守护进程，这些进程周期性地运行。
当空闲的页面太少时，会使用页面交换算法选取若干页面交换出去。</p>
 -->
    
        <p>操作系统笔记之二，内存管理。每一次上操作系统跟MAL都是智商上的一种煎熬啊……跟上一篇同样，这也是一些翻译ppt的内容，充作笔记。</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/c++/%E5%AE%89%E8%A3%85sdl/" title="安装SDL"><img src="http://MeowAlienOwO.github.io/images/8017236.jpg" alt="安装SDL"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-03-28T18:21:11+08:00"><a href="http://MeowAlienOwO.github.io/c++/%E5%AE%89%E8%A3%85sdl/">March 28, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/c++/%E5%AE%89%E8%A3%85sdl/" rel="bookmark" title="安装SDL" itemprop="url">安装SDL</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>上课Eugene让我们装个SDL说Coursework要用。嗯，Eugene自己使用Mac的，然后周四的课上又告诉我们怎么在VisualStudio上面装SDL
(虽然我是没搞定，不知道是因为那台电脑跟我冲怎么的)。</p>

<p>……</p>

<p>……</p>

<p>……</p>

<p>Linux呢！?用了Linux不带我玩咯？！</p>

<p><img src="http://MeowAlienOwO.github.ioimages/Wuying.jpg" alt="" /></p>

<h1 id="visual-studio-2013">Visual Studio 2013</h1>

<ol>
  <li>
    <p>下载安装包： <a href="https://libsdl.org/download-2.0.php">https://libsdl.org/download-2.0.php</a></p>
  </li>
  <li>
    <p>然后解压，放到一个适当的地方，记下路径 %path%</p>
  </li>
  <li>
    <p>打开Visual Studio，新建一个empty project</p>
  </li>
  <li>
    <p>在整个project上右键之，找到调整property的地方（反正在倒数几排）</p>
  </li>
  <li>在Visual C/C++ properties的地方（反正是这么回事）,找到Includes那一
行加入%path%\includes，找到Libraries那里加入%path%\lib\x86(为了兼容性)</li>
  <li>
    <p>在底下input那里加上SDL2.lib, SDL2main.lib</p>
  </li>
  <li>
    <p>在system那里设为console</p>
  </li>
  <li>
    <p>将压缩包里的dll文件复制到你的项目directory底下</p>
  </li>
  <li>fucking done…</li>
</ol>

<p>可能有记忆不清楚的地方，有空再改……</p>

<h1 id="ubuntu-linux">Ubuntu Linux</h1>

<p>听说包管理器可以搞定：</p>

<pre><code class="language-shell">sudo apt-get install libsdl2-dev
</code></pre>

<p>听说编译安装可以搞定：</p>

<p>到官网下载源码包，然后make&amp;&amp;make install</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">hg clone https://hg.libsdl.org/SDL SDL</span>
<span class="go">cd SDL</span>
<span class="go">mkdir build</span>
<span class="go">cd build</span>
<span class="go">../configure</span>
<span class="go">make</span>
<span class="go">sudo make install</span></code></pre></figure>

<p>没有hg的话自己装下……</p>

<p>于是我自己手动编译了一遍，不放心又用apt-get装了一遍。</p>

<p>然后挂了。g++可以编译，但是运行的时候返回”No available video device”。</p>

<p>为什么啊！老子按照教程装的啊！</p>

<p>于是开始各种google……有人说ubuntu自带没有x11的dev包……有人说改用i386
的，有人说环境变量没配置好的……</p>

<p>然后在
<a href="https://forums.libsdl.org/viewtopic.php?t=7321&amp;sid=1a10fc21944a39bba3e89eeae4e93b38">这里</a>
看到说:</p>

<blockquote>
  <p>Ubuntu does not ship with several important development headers and
libraries installed. This includes even the basic Xlib stuff, which
is why there is no video driver when you build SDL. You’re going to
need to install all of those yourself. The Software Manager tool
should be convenient here.</p>
</blockquote>

<p><strong>WHAT THE HELL?</strong></p>

<p>老子用了包管理器为何还是这个熊样？</p>

<p>于是接着google……然后看到<a href="http://wiki.libsdl.org/FAQLinux">官方wiki</a>的这个：</p>

<blockquote>
  <p>…if all those didn’t work, and you built SDL from source, make
sure that you have the X11 development libraries installed,
otherwise you’ll get a version of SDL that doesn’t include X11
display support.</p>
</blockquote>

<p>sudo apt-get remove &amp;&amp; make clean…</p>

<p>卸了重装，好了……</p>

<p>目测因为我是先编译安装后用包管理器的，而ubuntu自己本身缺了dev包，
那么我编译的版本也必然是没有dev包的。包管理器装上了x11，
但是库里的东西还是原来的样子，调用的时候是没有x11dev的编译版本。</p>

<p>……</p>

<p><img src="http://MeowAlienOwO.github.ioimages/linus-fuck-you.png" alt="" /></p>

<h1 id="mac-os">Mac OS</h1>

<p>哪个土豪送我一个啊啊啊啊啊</p>
 -->
    
        <p>上课Eugene让我们装个SDL说Coursework要用。嗯，Eugene自己使用Mac的，然后周四的课上又告诉我们怎么在VisualStudio上面装SDL
(虽然我是没搞定，不知道是因为那台电脑跟我冲怎么的)。</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://MeowAlienOwO.github.io/acg/%E7%A9%BA%E4%B9%8B%E5%A2%83%E7%95%8C/%E4%BF%AF%E7%9E%B0%E9%A3%8E%E6%99%AF/" title="俯瞰风景"><img src="http://MeowAlienOwO.github.io/images/48899625_p0.jpg" alt="俯瞰风景"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-03-06T22:18:16+08:00"><a href="http://MeowAlienOwO.github.io/acg/%E7%A9%BA%E4%B9%8B%E5%A2%83%E7%95%8C/%E4%BF%AF%E7%9E%B0%E9%A3%8E%E6%99%AF/">March 06, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://MeowAlienOwO.github.io/about/" title="About 死鱼眼的喵星人">死鱼眼的喵星人</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://MeowAlienOwO.github.io/acg/%E7%A9%BA%E4%B9%8B%E5%A2%83%E7%95%8C/%E4%BF%AF%E7%9E%B0%E9%A3%8E%E6%99%AF/" rel="bookmark" title="俯瞰风景" itemprop="url">俯瞰风景</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <p>我觉得空之境界是神作。我觉得空之境界是神作。因为很重要所以说了两遍。下面可能有若干剧透，
不想被剧透的请手动跳转<a href="http://www.bilibili.com/video/av1005743/index_1.html#">B站空境合集</a>，弹幕质量请注意。。</p>

<blockquote>
  <p>那一天，选择了办公区前的大路作为归途。</p>

  <p>对于自己是很鲜见的，单是心血来潮而已。</p>
</blockquote>

<p>如果要简单说起来的话，空境讲了如下几个故事：跟式姐抢男人的被干掉了，谷歌追式姐，
跟式姐抢男人的被干掉了，式姐出院了，跟谷歌抢女人的挂了，式姐帮谷歌的妹(qing)妹(di)解决事件，
式姐开挂，想要通吃式姐跟谷歌的男人被干掉了。嗯。</p>

<p>俯瞰风景作为空之境界的第一章，没有什么特别重要的内容，可以当作一个引子来看。不过初次看的话，
可能会被画风、表现手法、蘑菇的扯淡能力以及梶浦由记那种奇异（但是神作）的音乐给吓到。
故事情节相比后面各种倒叙的矛盾螺旋来说，已经算是非常简单了。巫条大楼自杀事件发生后，黑桐干也跑去调查时被巫条雾绘勾去魂魄，然后两仪式两入虎穴去找干也，最后橙子跟巫条雾绘补设定。不过这里有各种各样跟后面有关的伏笔，
比如巫条雾绘什么时候喜欢上黑桐干也，两仪式的义肢，黑桐干也来伽蓝之堂的一些经过，”「」”的意义等等，
看完复习的时候就好理解了。另外空境的打斗也都非常的酷炫，行云流水，比有些嘴炮秒全场的动漫甚至三次元物强多了，很值得一看。</p>

<blockquote>
  <p>在见惯的建筑群间呆呆地走着，</p>

  <p>不多时有人落了下来。</p>

  <p>没有太多机会听到的，啪嚓这样一声。</p>

  <p>很明显是有人从楼顶落下来并死去。</p>
</blockquote>

<p>我觉得蘑菇有一种奇异的倾向——别人是用一些贴近现实的东西做比喻来说明概念，他喜欢用说明概念来比喻人物……不知道是不是错觉。
贯穿全篇的概念（或者说是脑洞）是”飞翔“与”浮游“之间的区别。“飞翔”是带有目的性的逃走，而”浮游“是无目的的逃走。
然而，无论是飞翔还是浮游，对于人类而言，都是属于违背常识的举动，从伊卡洛斯飞向太阳而坠落开始，飞翔就同坠落密不可分。然而，他们在坠落的一刻仍然希望飞翔，正如橙子所言，他们不是落向地面而是坠落空中。因此，作为飞翔或者浮游的具现，巫条雾绘的悲剧从一开始就避免不了。</p>

<p>巫条雾绘在入院之后近似失去一切希望，然而黑桐干也每天的经过带给了她些许对生活的希望。后来，荒耶宗莲给予了她伊卡洛斯的翅膀——二重存在，使得她认为自己拥有了追寻希望的能力。然而，这种能力最终仍是错觉。且不论式姐的存在，荒耶宗莲自身也只是将巫条雾绘作为得到两仪式的工具而已。借由外物给予的力量，去追寻他人给予的希望，只不过是加速自己的灭亡罢了。</p>

<blockquote>
  <p>朱色在柏油路上流淌开来。</p>

  <p>仍保有原形的是长长的黑发。</p>

  <p>其中以及纤细的，让人联想到白色的脆弱手足。</p>

  <p>之后是已无容貌，破碎的面部。</p>

  <p>这一连串映像，让人不禁幻想到被挟入古老的书本。</p>

  <p>化为其中一页的压花。</p>
</blockquote>

<p>然而，无论怎么说，飞翔或是浮游，都是希望逃走的举动。因为自身被禁锢在医院内，身边亲近的人也都已经去世，也无外乎她想逃脱这个地方。包括喜欢干也，也只是逃避的一种举动。同样是被禁锢在医院内，两仪式的意识一直悬浮在根源之涡中，苏醒的代价是两仪织的消失，悲惨程度也相去不远。同样是失去了生存的实感，两仪式选择了坚强，斩杀了苏醒后因为心中的”「」”而脆弱的自己，终于寻找到人生意义，而巫条雾绘选择了无目的的浮游，等待着坠落的一刻到来。巫条雾绘无法竞争过两仪式，也就没什么奇怪了。但是，经过与两仪式的一战，她明白了所谓”如针一般，如剑一般，如雷一般贯穿我的死“，从死亡中，发现了生存的实感，也就无法再忍受生不如死地浮游着了。最后巫条雾绘选择了去尝试重现那曾经有过的生命的实感，努力去飞行，而不是呆在病床上等待着耗尽体力，无法浮游而坠落的死亡，从这种意义而言，两仪式也带给了巫条雾绘一种对于她而言的好结局吧。</p>

<p>无论其当事者的决意为何，自杀只能作为自杀被接受。无论本人怎么想，从无关者的外人看来，巫条雾绘依旧选择了自杀这一种懦弱的结末。不值得夸耀，不值得贬低，正如尘埃一般，存在，但并无什么价值。</p>

<blockquote>
  <p>仰望着天空，如同眺望着不存在的幻影般回答道。
“自杀没有理由。只是今天没有飞起来罢了。”</p>
</blockquote>
 -->
    
        <p>我觉得空之境界是神作。我觉得空之境界是神作。因为很重要所以说了两遍。下面可能有若干剧透，
不想被剧透的请手动跳转<a href="http://www.bilibili.com/video/av1005743/index_1.html#">B站空境合集</a>，弹幕质量请注意。。</p>


    
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->


<div class="pagination">
  
    
      <a href="http://MeowAlienOwO.github.io/page3" class="btn">Previous</a>
    
  
  <ul class="inline-list">
    <li>
      
        <a href="http://MeowAlienOwO.github.io">1</a>
      
    </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io/page2">2</a>
        
      </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io/page3">3</a>
        
      </li>
    
      <li>
        
          <span class="current-page">4</span>
        
      </li>
    
      <li>
        
          <a href="http://MeowAlienOwO.github.io/page5">5</a>
        
      </li>
    
  </ul>
  
    <a href="http://MeowAlienOwO.github.io/page5" class="btn">Next</a>
  
</div><!-- /.pagination -->

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2016 死鱼眼的喵星人. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="http://mademistakes.com/hpstr/" rel="notfollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://MeowAlienOwO.github.io/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://MeowAlienOwO.github.io/assets/js/scripts.min.js"></script>

<script type="text/javascript" src="/assets/js/vendor/share.min.js"></script>




          

</body>
</html>
